<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>钟声</title>
  <icon>https://www.gravatar.com/avatar/fa65dd480df94b0c4abae5c60b4365d4</icon>
  <subtitle>甘士忠个人博客</subtitle>
  <link href="http://shizhonggan.github.io/atom.xml" rel="self"/>
  
  <link href="http://shizhonggan.github.io/"/>
  <updated>2021-06-04T08:02:29.952Z</updated>
  <id>http://shizhonggan.github.io/</id>
  
  <author>
    <name>甘士忠</name>
    <email>gan_shizhong@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件定义网络（SDN）学习笔记(6)--Floodlight</title>
    <link href="http://shizhonggan.github.io/2021/06/03/SDN/SDN07_Floodlight/"/>
    <id>http://shizhonggan.github.io/2021/06/03/SDN/SDN07_Floodlight/</id>
    <published>2021-06-03T05:11:04.000Z</published>
    <updated>2021-06-04T08:02:29.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 通用版本java 卸载</span></span><br><span class="line">dpkg -l |grep -i jdk</span><br><span class="line">apt-get purge openjdk*</span><br><span class="line">apt-get purge icedtea-* openjdk-*</span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装1（此方法不行）</span></span><br><span class="line">sudo apt-get install build-essential ant python-dev</span><br><span class="line">sudo add-apt-repository ppa:webupd8team/java</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install oracle-java8-installer</span><br><span class="line"></span><br><span class="line"><span class="comment">## 安装2</span></span><br><span class="line">sudo mkdir /usr/lib/jvm</span><br><span class="line">sudo tar -zxvf jdk-8u181-linux-x64.tar.gz -C /usr/lib/jvm</span><br><span class="line"><span class="comment"># sudo vim ~/.bashrc</span></span><br><span class="line">sudo vim /etc/profile </span><br><span class="line">    <span class="comment">#set oracle jdk environment</span></span><br><span class="line">    <span class="built_in">export</span> JAVA_HOME=/home/ec2-user/jdk/jdk1.8.0_211  <span class="comment">## 这里要注意目录要换成自己解压的jdk 目录</span></span><br><span class="line">    <span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre  </span><br><span class="line">    <span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib  </span><br><span class="line">    <span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span>  </span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile </span><br><span class="line"></span><br><span class="line"><span class="comment">## 设置默认jdk(可不操作)</span></span><br><span class="line">sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/jdk1.8.0_181/bin/java 300  </span><br><span class="line">sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/jdk1.8.0_181/bin/javac 300  </span><br><span class="line">sudo update-alternatives --install /usr/bin/jar jar /usr/lib/jvm/jdk1.8.0_181/bin/jar 300   </span><br><span class="line">sudo update-alternatives --install /usr/bin/javah javah /usr/lib/jvm/jdk1.8.0_181/bin/javah 300   </span><br><span class="line">sudo update-alternatives --install /usr/bin/javap javap /usr/lib/jvm/jdk1.8.0_181/bin/javap 300</span><br><span class="line"></span><br><span class="line"><span class="comment">## 执行</span></span><br><span class="line">sudo update-alternatives --config java</span><br><span class="line"></span><br><span class="line"><span class="comment">## 检查</span></span><br><span class="line">java -version</span><br><span class="line">javac -version</span><br><span class="line"></span><br><span class="line"><span class="comment">## Floodlight</span></span><br><span class="line">sudo apt-get install build-essential default-jdk ant python-dev</span><br><span class="line">sudo apt-get install git</span><br><span class="line">git <span class="built_in">clone</span> -b v1.1 git://github.com/floodlight/floodlight.git  </span><br><span class="line"><span class="built_in">cd</span> floodlight</span><br><span class="line"><span class="comment"># git pull origin master </span></span><br><span class="line"><span class="comment"># git submodule init </span></span><br><span class="line"><span class="comment"># git submodule update </span></span><br><span class="line">ant</span><br><span class="line">ant eclipse</span><br><span class="line"></span><br><span class="line"><span class="comment">## 启动</span></span><br><span class="line">java -jar target/floodlight.jar</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#安装&quot;&gt;&lt;/a&gt; 安装&lt;/h2&gt;
&lt;figure class=&quot;highlight sh&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class</summary>
      
    
    
    
    <category term="SDN" scheme="http://shizhonggan.github.io/categories/SDN/"/>
    
    
    <category term="SDN" scheme="http://shizhonggan.github.io/tags/SDN/"/>
    
    <category term="Floodlight" scheme="http://shizhonggan.github.io/tags/Floodlight/"/>
    
  </entry>
  
  <entry>
    <title>软件定义网络（SDN）学习笔记(5)--OpenDaylight控制器</title>
    <link href="http://shizhonggan.github.io/2021/05/31/SDN/SDN05_OpenDaylight/"/>
    <id>http://shizhonggan.github.io/2021/05/31/SDN/SDN05_OpenDaylight/</id>
    <published>2021-05-31T05:11:04.000Z</published>
    <updated>2021-06-04T08:00:25.444Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SDN学习目录</p><blockquote><p><a href="/2021/04/09/SDN/SDN00_wireshark/">SDN学习笔记(0)–wireshark抓包分析</a></p><p><a href="/2021/04/15/SDN/SDN01_iPerf_Netperf/">SDN学习笔记(1)–iPerf和Netperf性能测试</a></p><p><a href="/2021/04/20/SDN/SDN02_Scapy_Postman/">SDN学习笔记(2)–Scapy交互式数据处理与Postman HTTP请求测试</a></p><p><a href="/2021/04/21/SDN/SDN03_ovs/">SDN学习笔记(3)–OVS系统架构</a></p><p><a href="/2021/05/31/SDN/SDN05_OpenDaylight/">SDN学习笔记(5)–OpenDaylight控制器</a></p></blockquote></blockquote><h2 id="1-OpenDaylight介绍"><a href="#1-OpenDaylight介绍" class="headerlink" title="1 OpenDaylight介绍"></a>1 OpenDaylight介绍</h2><p>控制器是给交换机下发流表的设备，最常见的控制器是OpenDaylight，简称ODL，下面首先安装一个ODL控制器，看看控制器给交换机下发的原汁原味的流表是怎么样的。</p><blockquote><p>心得：控制器还是属ODL好安装啊…界面丰富，新手上路不需要担心太多东西，就是软件太大。</p></blockquote><h2 id="2-ODL控制器安装"><a href="#2-ODL控制器安装" class="headerlink" title="2 ODL控制器安装"></a>2 ODL控制器安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 安装JAVA</span></span><br><span class="line">apt install openjdk-8-jdk</span><br><span class="line"></span><br><span class="line"><span class="comment">## 配置环境</span></span><br><span class="line">vim /etc/environment <span class="comment"># 进入环境变量配置文件，在第二行加入java的环境变量。</span></span><br><span class="line">    JAVA_HOME=<span class="string">&quot;/usr/lib/jvm/java-8-openjdk-amd64&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 下载ODL编译好的文件</span></span><br><span class="line">wget https://nexus.opendaylight.org/content/groups/public/org/opendaylight/integration/distribution-karaf/0.6.4-Carbon/distribution-karaf-0.6.4-Carbon.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">## 解压文件</span></span><br><span class="line">tar zvxf distribution-karaf-0.6.4-Carbon.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">## 配置文件</span></span><br><span class="line">/etc/org.apache.karaf.management.cfg</span><br><span class="line">    <span class="comment"># Host for RMI registry</span></span><br><span class="line">    rmiRegistryHost = 0.0.0.0</span><br><span class="line">    <span class="comment"># Port number for RMI server connection</span></span><br><span class="line">    rmiServerPort = 44444</span><br><span class="line">    <span class="comment"># Host for RMI server</span></span><br><span class="line">    rmiServerHost = 0.0.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment">## tmux 启动 odl</span></span><br><span class="line">tmux </span><br><span class="line"><span class="built_in">unset</span> TMOUT</span><br><span class="line"></span><br><span class="line">./bin/karaf</span><br><span class="line">feature:install odl-l2switch-switch-ui odl-openflowplugin-flow-services-ui odl-mdsal-apidocs odl-dluxapps-applications odl-faas-all</span><br></pre></td></tr></table></figure><h2 id="3-web界面"><a href="#3-web界面" class="headerlink" title="3 web界面"></a>3 web界面</h2><p>http://<your-karaf-ip>:8181/index.html</p><p>用户名：admin 密码：admin</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;SDN学习目录&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;/2021/04/09/SDN/SDN00_wireshark/&quot;&gt;SDN学习笔记(0)–wireshark抓包分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/2021/04</summary>
      
    
    
    
    <category term="SDN" scheme="http://shizhonggan.github.io/categories/SDN/"/>
    
    
    <category term="SDN" scheme="http://shizhonggan.github.io/tags/SDN/"/>
    
    <category term="OVS" scheme="http://shizhonggan.github.io/tags/OVS/"/>
    
    <category term="OpenDaylight" scheme="http://shizhonggan.github.io/tags/OpenDaylight/"/>
    
  </entry>
  
  <entry>
    <title>AWS云平台SDK boto3(python)--自动化创建实例、创建挂载卷以及远程操作</title>
    <link href="http://shizhonggan.github.io/2021/05/26/Python/aws_boto3_paramiko/"/>
    <id>http://shizhonggan.github.io/2021/05/26/Python/aws_boto3_paramiko/</id>
    <published>2021-05-26T00:36:04.000Z</published>
    <updated>2021-05-26T03:18:29.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-介绍"><a class="markdownIt-Anchor" href="#1-介绍"></a> 1 介绍</h2><p>Boto3是AWS python版的SDK，可以向python开发者在编写程序过程中使用Amazon S3和 Amazon EC2等服务。</p><p>Boto提供了简单的面向对象的API和基本的AWS相关服务。Boto3是最新版本，老版本例如boto2不建议使用。</p><p>这篇文章介绍了如何在本地windows环境下，进行AWS云服务的一些基本操作，例如创建实例创建、<br />卷创建和挂载、资源状态查询、资源使用后的清理回收，以及通过paramiko远程操作实例。</p><h2 id="2-安装环境"><a class="markdownIt-Anchor" href="#2-安装环境"></a> 2 安装环境</h2><ol><li><p>安装AWS CLI(Command Line Interface)<br />AWS命令行接口(CLI)是一个统一的工具来管理的AWS服务。只需下载并完成配置，便可以从命令行控制多个AWS服务，并通过脚本实现对AWS云服务的自动化操作。</p><p>下载链接：<a href="https://aws.amazon.com/cli/">https://aws.amazon.com/cli/</a></p><p>可参考 <a href="https://boto3.amazonaws.com/v1/documentation/api/latest/guide/configuration.html#guide-configuration">https://boto3.amazonaws.com/v1/documentation/api/latest/guide/configuration.html#guide-configuration</a><br />主要配置修改：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 修改 ~/.aws/credentials</span></span><br><span class="line">[default]</span><br><span class="line">aws_access_key_id = YOUR_KEY <span class="comment"># 你的</span></span><br><span class="line">aws_secret_access_key = YOUR_SECRET</span><br><span class="line"></span><br><span class="line"><span class="comment">## 修改 ~/.aws/config</span></span><br><span class="line">[default]</span><br><span class="line">region=cn-north-1a <span class="comment">#</span></span><br></pre></td></tr></table></figure></li><li><p>安装Boto3</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## python3</span></span><br><span class="line">pip install boto3</span><br></pre></td></tr></table></figure></li></ol><h2 id="3-基本命令"><a class="markdownIt-Anchor" href="#3-基本命令"></a> 3 基本命令</h2><h3 id="31-操作流程"><a class="markdownIt-Anchor" href="#31-操作流程"></a> 3.1 操作流程</h3><p>基本操作流程示例：</p><ul><li>创建实例</li><li>查询实例状态</li><li>创建卷</li><li>查看卷状态</li><li>若实例与卷均已创建完成并可以使用，挂载卷到已创建的云主机</li><li>资源使用完毕，清理回收</li></ul><h3 id="32-客户端和资源"><a class="markdownIt-Anchor" href="#32-客户端和资源"></a> 3.2 客户端和资源</h3><ol><li><p>boto3.client(“ec2”)</p><p>该命令主要可以进行EC2客户端的一些基本操作。例如：关联、挂载、创建、查询，取消、删除、修改等。</p></li><li><p>boto3.resource(“ec2”)</p><p>该命令主要可以进行EC2云服务中的各类资源的相关操作。该命令与client有交集的部分也有独立的一部分。</p></li></ol><h3 id="33-控制aws代码"><a class="markdownIt-Anchor" href="#33-控制aws代码"></a> 3.3 控制AWS代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> boto3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先调用以下两个</span></span><br><span class="line">ec2 = boto3.client(<span class="string">&quot;ec2&quot;</span>) </span><br><span class="line">ec2_resource = boto3.resource(<span class="string">&quot;ec2&quot;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建实例，返回的是实例的详细信息</span></span><br><span class="line">createInstance = ec2_resource.create_instances(</span><br><span class="line">    Placement=&#123;</span><br><span class="line">        <span class="string">&quot;AvailabilityZone&quot;</span>: <span class="string">&quot;cn-north-1b&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    ImageId=<span class="string">&quot;ami-0c52e2685c7218558&quot;</span>, <span class="comment"># 可先从AWS console上查看</span></span><br><span class="line">    InstanceType=<span class="string">&quot;t2.micro&quot;</span>,</span><br><span class="line">    MaxCount=<span class="number">1</span>, <span class="comment"># 可同时创建多个, </span></span><br><span class="line">    MinCount=<span class="number">1</span>,</span><br><span class="line">    KeyName=<span class="string">&quot;gsz&quot;</span>, <span class="comment"># 实现创建好的key pairs</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">instanceID = createInstance[<span class="number">0</span>].<span class="built_in">id</span> <span class="comment"># 从返回的数据中得到实例的ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 状态查询,是为了等待创建成功，状态可使用情况下进行下一步操作</span></span><br><span class="line">instance_state = ec2_resource.Instance(instanceID).state[<span class="string">&quot;Name&quot;</span>] <span class="comment"># 根据实例ID查询状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 创建卷，此处貌似&quot;ec2&quot;和&quot;ec2_resource&quot;都具有创建卷的方法</span></span><br><span class="line">snap2vol = ec2.create_volume(</span><br><span class="line">    AvailabilityZone= <span class="string">&quot;cn-north-1b&quot;</span>, <span class="comment"># 要与创建的实例相同</span></span><br><span class="line">    Encrypted=<span class="literal">True</span>,</span><br><span class="line">    Size = <span class="number">100</span>, <span class="comment"># 单位GiBs</span></span><br><span class="line">    SnapshotId = <span class="string">&quot;snap-096b5af48e45fe262&quot;</span> <span class="comment"># 通过某个快照ID创建，如无则为常规卷</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 挂载卷</span></span><br><span class="line">volID = create_vol[<span class="string">&#x27;VolumeId&#x27;</span>] <span class="comment"># 获取卷ID</span></span><br><span class="line">attach_vol2 = ec2.attach_volume(</span><br><span class="line">    ice=Device2,  <span class="comment"># 挂载路径  /dev/sdf</span></span><br><span class="line">    InstanceId=InstanceID,  <span class="comment"># 实例ID</span></span><br><span class="line">    VolumeId=volID, <span class="comment">#卷ID</span></span><br><span class="line">)</span><br><span class="line">attach_state = ec2_resource.Volume(datavolID).attachments[<span class="number">0</span>][<span class="string">&#x27;State&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除资源</span></span><br><span class="line">instance = ec2_resource.Instance(instanceID)</span><br><span class="line">instance.terminate()</span><br><span class="line">volume = ec2_resource.Volume(vol_id)</span><br><span class="line">volume.delete()</span><br></pre></td></tr></table></figure><h3 id="34-远程操作云主机"><a class="markdownIt-Anchor" href="#34-远程操作云主机"></a> 3.4 远程操作云主机</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="comment">## 实例化SSHClinet</span></span><br><span class="line">sshc = paramiko.SSHClient()</span><br><span class="line">sshc.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">sshc.connect(host, username=username,port=port,pkey=key)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 传文件</span></span><br><span class="line">sftp = sshc.open_sftp()</span><br><span class="line">localfile1 = <span class="string">&quot;path to your locoal file&quot;</span></span><br><span class="line">remotepath1 = <span class="string">&quot;path/file.name&quot;</span></span><br><span class="line">sftp.put(localfile1, remotepath1)</span><br><span class="line">sftp.close()</span><br><span class="line"></span><br><span class="line">commands = [</span><br><span class="line">    <span class="string">&quot;shell command list&quot;</span></span><br><span class="line">]</span><br><span class="line"><span class="keyword">for</span> command <span class="keyword">in</span> commands:</span><br><span class="line">    stdin, stdout, stderr = sshc.exec_command(command)</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a class="markdownIt-Anchor" href="#参考资料"></a> 参考资料</h2><p>Paramiko: <a href="https://www.cnblogs.com/xiao-apple36/p/9144092.html">https://www.cnblogs.com/xiao-apple36/p/9144092.html</a></p><p>Boto3: <a href="https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#ec2">https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#ec2</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-介绍&quot;&gt;&lt;/a&gt; 1 介绍&lt;/h2&gt;
&lt;p&gt;Boto3是AWS python版的SDK，可以向python开发者在编写程序过程中使用Amazon S3和 Amazon EC2等</summary>
      
    
    
    
    <category term="AWS" scheme="http://shizhonggan.github.io/categories/AWS/"/>
    
    
    <category term="AWS" scheme="http://shizhonggan.github.io/tags/AWS/"/>
    
    <category term="boto3" scheme="http://shizhonggan.github.io/tags/boto3/"/>
    
    <category term="paramiko" scheme="http://shizhonggan.github.io/tags/paramiko/"/>
    
  </entry>
  
  <entry>
    <title>Paramiko执行后台命令报错</title>
    <link href="http://shizhonggan.github.io/2021/05/20/Python/paramiko/"/>
    <id>http://shizhonggan.github.io/2021/05/20/Python/paramiko/</id>
    <published>2021-05-20T01:39:04.000Z</published>
    <updated>2021-05-20T05:29:52.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-报错关键字"><a class="markdownIt-Anchor" href="#1-报错关键字"></a> 1. 报错关键字</h2><ul><li>paramiko</li><li>Exception ignored in: &lt;function BufferedFile.<strong>del</strong> at 0x000001E62C28A048&gt;</li><li>TypeError: ‘NoneType’ object is not callable</li></ul><h2 id="2-代码"><a class="markdownIt-Anchor" href="#2-代码"></a> 2. 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line">sshc = paramiko.SSHClient()</span><br><span class="line">sshc.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">sshc.connect(host, username=username,port=port,pkey=key)</span><br><span class="line">stdin1, stdout1, stderr1 = sshc.exec_command(<span class="string">&quot;setsid ...(省略)... &amp;&quot;</span>) </span><br></pre></td></tr></table></figure><p>setsid是linux系统命令，如果再window下写的代码此处必然无法运行。可以先将setsid相关代码通过sshc.open_sftp()上传到服务端，然后通过sshc.exec_command(“python <a href="http://setsid.py">setsid.py</a>”)运行脚本。</p><h3 id="nohup-与-setsid-区别"><a class="markdownIt-Anchor" href="#nohup-与-setsid-区别"></a> nohup 与 setsid 区别</h3><p>参考：<a href="http://www.tang-lei.com/2019/03/04/linux-nohup-setsid-%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%88%AB/">http://www.tang-lei.com/2019/03/04/linux-nohup-setsid-使用区别/</a></p><ul><li><p>nohup</p><p>nohup命令的功能就是使用当前进程忽略hangup信号，从而继续执行。默认的标准输入输出都会被重定向到当前目录下的nohup.out文件里。一般我们配置在命令的末尾加上 &amp; 来配合使用。</p><p>可以通过 &gt;filename 2&gt;&amp;1 来重定向默认的输入输出, 如：”nohup minio server :9001 /mnt/test/ &gt; /var/log/minio_test.log 2&gt;&amp;1 &amp;”, 通过jobs 可以看到该进程的父进程是当前shell的进程号</p><p>作用说明：进程在后台执行；忽略hangup信号；重定向日志输出</p></li><li><p>&amp;</p><p>&amp; 代表后台运行程序。如果终端退出，则该进程会结束。通常配合nohup和setsid使用</p></li><li><p>setsid</p><p>setsid 就是set session id 的意思。表示该命令运行的进程是一个新的session。因此其父进程不属于当前终端。实际上setsid运行的进程，其父进程id(ppid)为1(init进程的id)。</p><p>如：”setsid minion server :9001 /mnt/test/ &gt; /var/log/minio_test.log &amp;”。注意：setsid输出重定向必须手动指定。</p></li><li><p>结论</p><p>由于nohup的父进程与当前的worker有关，当我们Ctrl+C的时候，也会把其给kill掉。而setsid的父进程是init,所以当我们退出worker的时候，并不会kill掉该服务</p></li></ul><h2 id="3-输出"><a class="markdownIt-Anchor" href="#3-输出"></a> 3. 输出</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception ignored <span class="keyword">in</span>: &lt;function BufferedFile.__del__ at <span class="number">0x000001E62C28A048</span>&gt;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;C:\ProgramData\Anaconda3\lib\site-packages\paramiko\file.py&quot;</span>, line <span class="number">66</span>, <span class="keyword">in</span> __del__</span><br><span class="line">  File <span class="string">&quot;C:\ProgramData\Anaconda3\lib\site-packages\paramiko\channel.py&quot;</span>, line <span class="number">1392</span>, <span class="keyword">in</span> close</span><br><span class="line">  File <span class="string">&quot;C:\ProgramData\Anaconda3\lib\site-packages\paramiko\channel.py&quot;</span>, line <span class="number">991</span>, <span class="keyword">in</span> shutdown_write</span><br><span class="line">  File <span class="string">&quot;C:\ProgramData\Anaconda3\lib\site-packages\paramiko\channel.py&quot;</span>, line <span class="number">963</span>, <span class="keyword">in</span> shutdown</span><br><span class="line">  File <span class="string">&quot;C:\ProgramData\Anaconda3\lib\site-packages\paramiko\channel.py&quot;</span>, line <span class="number">1246</span>, <span class="keyword">in</span> _send_eof</span><br><span class="line">  File <span class="string">&quot;C:\ProgramData\Anaconda3\lib\site-packages\paramiko\message.py&quot;</span>, line <span class="number">232</span>, <span class="keyword">in</span> add_int</span><br><span class="line">TypeError: <span class="string">&#x27;NoneType&#x27;</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">callable</span></span><br></pre></td></tr></table></figure><h2 id="4-解决方法"><a class="markdownIt-Anchor" href="#4-解决方法"></a> 4. 解决方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## main.py</span></span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line">sshc = paramiko.SSHClient()</span><br><span class="line">sshc.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line">sshc.connect(host, username=username,port=port,pkey=key)</span><br><span class="line"></span><br><span class="line">sftp = sshc.open_sftp()</span><br><span class="line">localfile = <span class="string">&quot;cmd.py&quot;</span></span><br><span class="line">remotepath = <span class="string">&quot;/path/cmd.py&quot;</span></span><br><span class="line">sftp.put(localfile, remotepath)</span><br><span class="line">stdin, stdout1, stderr = sshc.exec_command(<span class="string">&quot;python &quot;</span>+<span class="string">&quot;cmd.py&quot;</span>) </span><br><span class="line">sshc.close()</span><br><span class="line"></span><br><span class="line"><span class="comment">## cmd.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">SnapID = <span class="string">&quot;snap-096b5af48e45fe262&quot;</span></span><br><span class="line">datapath = <span class="string">&quot;/mnt/snap/8572302701/hda/data.gz.aes&quot;</span></span><br><span class="line">opensslcmd = os.popen( <span class="comment"># 此处选用os.popen，主要是怀疑paramiko存在问题</span></span><br><span class="line"><span class="string">&quot;setsid ...(your shell commands)... &amp;&quot;</span></span><br><span class="line">)</span><br><span class="line">sys.exit()</span><br></pre></td></tr></table></figure><p>将代码最后添加一个sys.exit()程序恢复正常,其实主要ssh返回的结果缓冲释放过快未读完，就产生报错了。也有说，加一个sleep 1秒也可以解决。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-报错关键字&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-报错关键字&quot;&gt;&lt;/a&gt; 1. 报错关键字&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;paramiko&lt;/li&gt;
&lt;li&gt;Exception ignored in: &amp;lt;functi</summary>
      
    
    
    
    <category term="运维" scheme="http://shizhonggan.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
    <category term="paramiko" scheme="http://shizhonggan.github.io/tags/paramiko/"/>
    
    <category term="python" scheme="http://shizhonggan.github.io/tags/python/"/>
    
    <category term="DevOps" scheme="http://shizhonggan.github.io/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>学术论文免费下载方法</title>
    <link href="http://shizhonggan.github.io/2021/05/18/Tips/PaperDownload/"/>
    <id>http://shizhonggan.github.io/2021/05/18/Tips/PaperDownload/</id>
    <published>2021-05-18T13:44:23.000Z</published>
    <updated>2021-05-20T01:29:42.921Z</updated>
    
    <content type="html"><![CDATA[<p>本文仅测试了IEEE论文的下载，亲测有效。</p><p>打开网址<a href="https://scihubtw.tw/">scihubtw.tw</a>，网站如下：</p><p><img src="https://ganshizhong.gitee.io/blogimages/Tips/PaperDownload/SCI-HUB.png" alt="SCI-HUB网址" /></p><p>IEEE搜索你需要下载的文章，打开文章所在页面如下图所示，其中红色框内的链接和DOI编号都可以在SCI-HUB中搜索，然后即可下载。</p><p><img src="https://ganshizhong.gitee.io/blogimages/Tips/PaperDownload/IEEEpaperExample.png" alt="SCI-HUB网址" /></p><blockquote><p>温馨提示：SCI-HUB网址会经常变更，需要多加留意啊~</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文仅测试了IEEE论文的下载，亲测有效。&lt;/p&gt;
&lt;p&gt;打开网址&lt;a href=&quot;https://scihubtw.tw/&quot;&gt;scihubtw.tw&lt;/a&gt;，网站如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ganshizhong.gitee.io/blogi</summary>
      
    
    
    
    <category term="Tips" scheme="http://shizhonggan.github.io/categories/Tips/"/>
    
    
  </entry>
  
  <entry>
    <title>Docker 常用命令方法</title>
    <link href="http://shizhonggan.github.io/2021/04/28/Docker/basic_method/"/>
    <id>http://shizhonggan.github.io/2021/04/28/Docker/basic_method/</id>
    <published>2021-04-28T03:03:04.000Z</published>
    <updated>2021-05-27T00:44:12.115Z</updated>
    
    <content type="html"><![CDATA[<ol><li>镜像搜索、拉取和使用</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker search ubuntu</span><br><span class="line">docker pull ubuntu</span><br><span class="line">docker run -it --name test ubuntu /bin/bash</span><br><span class="line">docker start test</span><br><span class="line">docker restart test</span><br><span class="line">docker stop test</span><br></pre></td></tr></table></figure><ol start="2"><li>将容器保存为镜像，便于重复使用</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt-get install net-tools</span><br><span class="line">apt-get install -y inetutils-ping</span><br><span class="line">apt-get install iproute2</span><br><span class="line">docker commit -a &quot;作者名&quot; -m &quot;镜像描述&quot; 容器ID 新镜像命名</span><br><span class="line">docker commit -a &quot;paxton&quot; -m &quot;ubuntu with modified apt source.list&quot; ovs1 mdubuntu</span><br></pre></td></tr></table></figure><ol start="3"><li>自定义网络</li></ol><ul><li>docker的网络通信基于安装时新建的docker0网桥，可以与外网，本虚拟机以及其他虚拟机通信</li><li>在两台虚拟机上创建自定义网络，并为新建容器分配自定义网络下的ip地址，两台虚拟机分配不同网段，配置操作如下：</li></ul><p>虚拟机1-ip：192.168.255.129 容器网段 10.0.30.0/24 容器ip：10.0.30.10</p><p>虚拟机1操作如下：</p><p>创建自定义网络，ifconfig可发现多出一个网桥</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## h0</span></span><br><span class="line">docker network create --subnet=10.0.30.0/24 --opt com.docker.network.driver.mtu=1450 docker-br0 </span><br><span class="line">docker run -itd --net docker-br0 --ip 10.0.30.10 --name h0 mdubuntu /bin/bash</span><br><span class="line"><span class="comment">## h1</span></span><br><span class="line">docker network create --subnet=10.0.50.0/24 --opt com.docker.network.driver.mtu=1450 docker-br1 </span><br><span class="line">docker run -itd --net docker-br1 --ip 10.0.50.10 --name h1 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>此时，新建的两个虚拟机相互无法ping通。可以通过增加路由的方式解决：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ip route show <span class="comment"># 查看一下当前路由</span></span><br><span class="line"></span><br><span class="line">docker network connect docker-br0 h1 <span class="comment"># 将h1加入到h0所在的自定义网络docker-br0中，进入h1可ping通h0，h0不可ping通h1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/tengj/p/5357879.html">https://www.cnblogs.com/tengj/p/5357879.html</a><br /><a href="https://blog.csdn.net/Silvester123/article/details/80867168">https://blog.csdn.net/Silvester123/article/details/80867168</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;镜像搜索、拉取和使用&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    <category term="Docker" scheme="http://shizhonggan.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://shizhonggan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 容器内网络无法连接</title>
    <link href="http://shizhonggan.github.io/2021/04/27/Docker/netdisconnected/"/>
    <id>http://shizhonggan.github.io/2021/04/27/Docker/netdisconnected/</id>
    <published>2021-04-27T08:09:04.000Z</published>
    <updated>2021-05-26T05:55:52.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h2><p>ubuntu16<br />docker 参照官方教程安装最新版本</p><h2 id="问题描述"><a class="markdownIt-Anchor" href="#问题描述"></a> 问题描述</h2><p>最近迷恋上了docker，因为官方提供的ubuntu镜像只有64M!!!十分轻便。<br />然而基于该镜像生成的容器无法联网，参见下面代码错误，然后试了试其它镜像，依旧无法联网。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@gan# docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              latest              a2a15febcdf3        7 days ago          64.2MB</span><br><span class="line">root@e6a2c5bec004:/# apt update</span><br><span class="line">Err:1 http://security.ubuntu.com/ubuntu bionic-security InRelease</span><br><span class="line">  Connection failed [IP: 91.189.88.162 80]</span><br><span class="line">Err:2 http://archive.ubuntu.com/ubuntu bionic InRelease</span><br><span class="line">  Connection failed [IP: 91.189.88.149 80]</span><br><span class="line">Err:3 http://archive.ubuntu.com/ubuntu bionic-updates InRelease</span><br><span class="line">  Connection failed [IP: 91.189.88.24 80]</span><br><span class="line">Err:4 http://archive.ubuntu.com/ubuntu bionic-backports InRelease</span><br><span class="line">  Connection failed [IP: 91.189.88.149 80]</span><br><span class="line">Reading package lists... Done</span><br><span class="line">Building dependency tree</span><br><span class="line">Reading state information... Done</span><br><span class="line">All packages are up to date.</span><br><span class="line">W: Failed to fetch http://archive.ubuntu.com/ubuntu/dists/bionic/InRelease  Conn                    ection failed [IP: 91.189.88.149 80]</span><br><span class="line">W: Failed to fetch http://archive.ubuntu.com/ubuntu/dists/bionic-updates/InRelea                    se  Connection failed [IP: 91.189.88.24 80]</span><br><span class="line">W: Failed to fetch http://archive.ubuntu.com/ubuntu/dists/bionic-backports/InRel                    ease  Connection failed [IP: 91.189.88.149 80]</span><br><span class="line">W: Failed to fetch http://security.ubuntu.com/ubuntu/dists/bionic-security/InRel                    ease  Connection failed [IP: 91.189.88.162 80]</span><br><span class="line">W: Some index files failed to download. They have been ignored, or old ones used                     instead.</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解决办法"><a class="markdownIt-Anchor" href="#解决办法"></a> 解决办法</h2><p>例如：<br /><a href="https://blog.csdn.net/yangzhenping/article/details/43567155">Docker容器内不能联网的6种解决方案</a><br /><a href="https://stackoverflow.com/questions/24832972/docker-apt-get-update-fails">stack overflow中的高分回复 Docker apt-get update fails</a><br />中文这六种解决方法，不要轻易动用，除非你之前做过大量的网络设置，负责这些问题基本不会出现。</p><h3 id="第一步首先查看docker虚拟网卡查看mtu值如果是1500默认或者更大则需要修改为1450或者更小etcdockerdaemonjson-此外可以在daemonjson中修改镜像的存储路径以免占用太多的系统内存修改mtu值便可以联网了dns根据情况修改可以不加吧"><a class="markdownIt-Anchor" href="#第一步首先查看docker虚拟网卡查看mtu值如果是1500默认或者更大则需要修改为1450或者更小etcdockerdaemonjson-此外可以在daemonjson中修改镜像的存储路径以免占用太多的系统内存修改mtu值便可以联网了dns根据情况修改可以不加吧"></a> 第一步：首先查看docker虚拟网卡，查看mtu值，如果是1500(默认，或者更大)，则需要修改为1450或者更小，/etc/docker/daemon.json 。此外，可以在daemon.json中修改镜像的存储路径，以免占用太多的系统内存；修改mtu值便可以联网了；dns根据情况修改，可以不加吧。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">root@gan:/etc/docker# ifconfig</span><br><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1450</span><br><span class="line">        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255</span><br><span class="line">        inet6 fe80::42:7eff:fee3:87ab  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:7e:e3:87:ab  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 4518  bytes 281479 (281.4 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 5733  bytes 17386562 (17.3 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"><span class="meta">root@gan#</span><span class="bash"> vim /etc/docker/daemon.json</span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;data-root&quot;: &quot;/home/ec2-user/software/docker-data&quot;,</span><br><span class="line">    &quot;storage-driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">    &quot;mtu&quot;: 1450, </span><br><span class="line">    &quot;dns&quot;: [&quot;you_server_dns&quot;,&quot;8.8.8.8&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#启动</span></span> </span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 守护进程重启</span></span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 重启docker服务</span></span></span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 关闭docker</span></span></span><br><span class="line">sudo systemctl stop docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 重启docker服务</span></span></span><br><span class="line">sudo service docker restart</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 关闭docker</span></span></span><br><span class="line">sudo service docker stop</span><br></pre></td></tr></table></figure><h3 id="第二步再按照其它方法慢慢修改吧"><a class="markdownIt-Anchor" href="#第二步再按照其它方法慢慢修改吧"></a> 第二步：再按照其它方法慢慢修改吧</h3><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>有时候搜索不到答案，就细致读一下官方文档，按照官方文档操作一般不会遇到问题，否则就是这个软件的BUG了。</p><p><strong>MTU [百度百科]</strong><br />通信术语 最大传输单元（Maximum Transmission Unit，MTU）是指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。最大传输单元这个参数通常与通信接口有关（网络接口卡、串口等）。</p><ul><li>因为协议数据单元的包头和包尾的长度是固定的，MTU越大，则一个协议数据单元的承载的有效数据就越长，通信效率也越高。MTU越大，传送相同的用户数据所需的数据包个数也越低。</li><li>MTU也不是越大越好，因为MTU越大， 传送一个数据包的延迟也越大；并且MTU越大，数据包中 bit位发生错误的概率也越大。</li><li>MTU越大，通信效率越高而传输延迟增大，所以要权衡通信效率和传输延迟选择合适的MTU。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;操作系统&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#操作系统&quot;&gt;&lt;/a&gt; 操作系统&lt;/h2&gt;
&lt;p&gt;ubuntu16&lt;br /&gt;
docker 参照官方教程安装最新版本&lt;/p&gt;
&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a class=&quot;mar</summary>
      
    
    
    
    <category term="Docker" scheme="http://shizhonggan.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://shizhonggan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu安装Docker与最常用配置</title>
    <link href="http://shizhonggan.github.io/2021/04/26/Docker/docker_install/"/>
    <id>http://shizhonggan.github.io/2021/04/26/Docker/docker_install/</id>
    <published>2021-04-26T02:54:04.000Z</published>
    <updated>2021-04-28T03:02:58.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-docker-介绍"><a class="markdownIt-Anchor" href="#1-docker-介绍"></a> 1 docker 介绍</h2><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><p>Docker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。</p><p>Docker的应用场景</p><ul><li>Web 应用的自动化打包和发布。</li><li>自动化测试和持续集成、发布。</li><li>在服务型环境中部署和调整数据库或其他的后台应用。</li><li>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</li></ul><p>Docker 的优点</p><ul><li>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。<ol><li><p>快速，一致地交付您的应用程序</p><p>Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。</p><p>容器非常适合持续集成和持续交付（CI / CD）工作流程，请考虑以下示例方案：</p><p>您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。<br />他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。<br />当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。<br />测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。</p></li><li><p>响应式部署和扩展<br />Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。</p><p>Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</p></li><li><p>在同一硬件上运行更多工作负载</p><p>Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。</p></li></ol></li></ul><h2 id="安装"><a class="markdownIt-Anchor" href="#安装"></a> 安装</h2><p>ubuntu16.04安装成功；ubuntu14.04安装失败【<strong>各种报错啊，有耐心的可以慢慢去解决</strong>】。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo rm /etc/apt/sources.list</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vi /etc/apt/sources.list</span></span><br><span class="line"></span><br><span class="line">echo \</span><br><span class="line">&quot;deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse&quot; \</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt; /etc/apt/sources.list</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get update</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get upgrade</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get remove docker docker-engine docker.io containerd runc <span class="comment"># 如果存在旧版本地docker产品先卸载</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> </span></span><br></pre></td></tr></table></figure><ul><li>Install using the repository</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install apt-transport-https ca-certificates curl gnupg lsb-release</span><br><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br><span class="line">$ <span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(lsb_release -cs)</span> stable&quot;</span> | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure><ul><li>INSTALL DOCKER CE</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install docker-ce docker-ce-cli containerd.io</span><br><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure><ul><li>docker 更改工作存储路径【可选操作】</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl stop docker</span><br></pre></td></tr></table></figure><p>Runtime directory and storage driver <br />You may want to control the disk space used for Docker images, containers, and volumes by moving it to a separate partition.<br />To accomplish this, set the following flags in the daemon.json file:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data-root&quot;: &quot;/mnt/docker-data&quot;, ## 修改成你自己的目录</span><br><span class="line">    &quot;storage-driver&quot;: &quot;overlay2&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker start # 重启</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><ul><li>Docker 更改容器日志文件大小【可选操作】</li></ul><p>docker容器的日志文件会不断挤占系统资源内存，因此需要限定docker日志文件大小，实现docker日志定期处理，具体方法如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看文件夹子文件所占内存大小</span></span><br><span class="line">du -h --max-depth=1 /home/ec2-user/dirname/</span><br><span class="line"></span><br><span class="line"><span class="comment"># vim /etc/docker/daemon.json</span></span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">  &quot;log-driver&quot;:&quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;&quot;max-size&quot;:&quot;500m&quot;, &quot;max-file&quot;:&quot;1&quot;&#125;  # max-size=500m，意味着一个容器日志大小上限是500M，max-file=3，意味着一个容器有三个日志，分别是id+.json、id+1.json、id+2.json。</span><br><span class="line">&#125; ##  重启docker守护进程 # systemctl daemon-reload 、# systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-docker-介绍&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-docker-介绍&quot;&gt;&lt;/a&gt; 1 docker 介绍&lt;/h2&gt;
&lt;p&gt;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议</summary>
      
    
    
    
    <category term="Docker" scheme="http://shizhonggan.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://shizhonggan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>面向对象编程(python)</title>
    <link href="http://shizhonggan.github.io/2021/04/26/Python/ObjectOrientedPrograming/"/>
    <id>http://shizhonggan.github.io/2021/04/26/Python/ObjectOrientedPrograming/</id>
    <published>2021-04-26T02:54:04.000Z</published>
    <updated>2021-05-13T09:16:16.755Z</updated>
    
    <content type="html"><![CDATA[<p>与面向过程相比，面向对象优缺点如下：</p><ul><li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护<ul><li>数据抽象的概念可以在保持外部接口不变的情况下改变内部实现，从而减少甚至避免对外界的干扰；</li><li>通过继承大幅减少冗余的代码，并可以方便地扩展现有代码，提高编码效率，也减低了出错概率，降低软件维护的难度；</li><li>结合面向对象分析、面向对象设计，允许将问题域中的对象直接映射到程序中，减少软件开发过程中中间环节的转换过程；</li><li>通过对对象的辨别、划分可以将软件系统分割为若干相对独立的部分，在一定程度上更便于控制软件复杂度；</li><li>以对象为中心的设计可以帮助开发人员从静态（属性）和动态（方法）两个方面把握问题，从而更好地实现系统；</li><li>通过对象的聚合、联合可以在保证封装与抽象的原则下实现对象在内在结构以及外在功能上的扩充，从而实现对象由低到高的升级。</li></ul></li><li>缺点：性能比面向过程低</li></ul><p>自己写</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;与面向过程相比，面向对象优缺点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护
&lt;ul&gt;
&lt;li&gt;数据抽象的概念可以在保持外部接口不变的情况下改变内部实现，从而减少</summary>
      
    
    
    
    <category term="Python" scheme="http://shizhonggan.github.io/categories/Python/"/>
    
    
    <category term="OOP" scheme="http://shizhonggan.github.io/tags/OOP/"/>
    
  </entry>
  
  <entry>
    <title>软件定义网络（SDN）学习笔记(3)--OVS系统架构</title>
    <link href="http://shizhonggan.github.io/2021/04/21/SDN/SDN03_ovs/"/>
    <id>http://shizhonggan.github.io/2021/04/21/SDN/SDN03_ovs/</id>
    <published>2021-04-21T13:31:04.000Z</published>
    <updated>2021-06-04T08:02:41.386Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SDN学习目录</p><blockquote><p><a href="/2021/04/09/SDN/SDN00_wireshark/">SDN学习笔记(0)–wireshark抓包分析</a></p><p><a href="/2021/04/15/SDN/SDN01_iPerf_Netperf/">SDN学习笔记(1)–iPerf和Netperf性能测试</a></p><p><a href="/2021/04/20/SDN/SDN02_Scapy_Postman/">SDN学习笔记(2)–Scapy交互式数据处理与Postman HTTP请求测试</a></p><p><a href="/2021/04/21/SDN/SDN03_ovs/">SDN学习笔记(3)–OVS系统架构</a></p><p><a href="/2021/05/31/SDN/SDN05_OpenDaylight/">SDN学习笔记(5)–OpenDaylight控制器</a></p></blockquote></blockquote><h2 id="1-基本概念"><a class="markdownIt-Anchor" href="#1-基本概念"></a> 1 基本概念</h2><h3 id="11-交换机"><a class="markdownIt-Anchor" href="#11-交换机"></a> 1.1 交换机</h3><p>交换机（Switch）是一种在通信系统中完成信息交换功能的设备。它可以为接入交换机的任意两个网络节点提供独享的电信号通路。最常见的交换机是以太网交换机。其他常见的还有电话语音交换机、光纤交换机等。目前，二层交换技术发展比较成熟，二层交换机（Layer 2 switches）是指只支持OSI第二层（数据链路层）交换技术的交换机。</p><h3 id="12-工作原理"><a class="markdownIt-Anchor" href="#12-工作原理"></a> 1.2 工作原理</h3><p>交换机拥有一条很高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条背部总线上，控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部交换矩阵迅速将数据包传送到目的端口，目的MAC若不存在，广播到所有的端口，接收端口回应后交换机会“学习”新的MAC地址，并把它添加入内部MAC地址表中，并刷新CAM表，表中有MAC地址，对应的端口号，端口所属的VLAN信息，交换机在二层转发数据时根据CAM表查找出端口。使用交换机也可以把网络“分段”，通过对照IP地址表，交换机只允许必要的网络流量通过交换机。通过交换机的过滤和转发，可以有效的减少冲突域，但不能划分广播域。交换机在同一时刻可进行多个端口对之间的数据传输。每一端口都可视为独立的网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。当节点A向节点D发送数据时，节点B可同时向节点C发送数据，而且这两个传输都享有网络的全部带宽，有着自己的虚拟连接。</p><h3 id="13-作用与功能"><a class="markdownIt-Anchor" href="#13-作用与功能"></a> 1.3 作用与功能</h3><p>交换机的常见功能如下：</p><ul><li>MAC地址学习：以太网交换机了解每一端口相连设备的MAC地址，并将地址同相应的端口映射起来存放在交换机缓存中的MAC地址表中。</li><li>转发/过滤：当一个数据帧的目的地址在MAC地址表中有映射时，它被转发到连接目的节点的端口而不是所有端口（如该数据帧为广播/组播帧则转发至所有端口）。</li><li>消除回路：当交换机包括一个冗余回路时，以太网交换机通过生成树协议避免回路的产生，同时允许存在后备路径。</li></ul><h2 id="2-open-vswitch-ovs"><a class="markdownIt-Anchor" href="#2-open-vswitch-ovs"></a> 2 Open vSwitch (OVS)</h2><p>在网络中，交换机和桥概念类似，Open vSwitch是一个虚拟交换软件，也就是说，Open vSwitch实现了网桥的功能。学习Open vSwitch的第一步要弄清楚网桥的概念。网桥是连接两个局域网的设备，工作在数据链路层，根据MAC地址来转发帧。在Open vSwitch中创建一个网桥后，此时网络功能不受影响，但是会产生一个虚拟网卡，之所以会产生一个虚拟网卡，是为了实现接下来的网桥（交换机）功能。有了这个网桥以后，还需要为这个网桥增加端口（port），一个端口就是一个物理网卡，当网卡加入到这个网桥之后，其工作方式就和普通交换机的一个端口的工作方式类似了。以下是一个网桥的具体信息：</p><p>Open vSwitch（OVS）是一个高质量的、多层虚拟交换机。OVS遵循开源Apache2.0许可，通过可编程扩展，OVS可以实现大规模网络的自动化（配置、管理、维护），同时支持现有标准管理接口和协议（比如NetFlow、sFlow、SPAN、RSPAN、CLI、LACP、802.1ag等）。此外OVS支持多种Linux虚拟化技术，包括Xen/XenServer，KVM，和VirtualBox等。虽然是虚拟交换机，但是其工作原理与物理交换机类似。在虚拟交换机的实现中，其两端分别连接着物理网卡和多块虚拟网卡，同时虚拟交换机内部会维护一张映射表，根据MAC地址寻找对应的虚拟机链路进而完成数据转发。</p><p>OVS交换机有两种工作模式</p><ul><li>一种为SDN交换机，另一种为普通交换机。作为SDN交换机时，显示Fail_mode为Secure，在这种模式下OVS交换机需要控制器发送转发规则，指挥交换机去工作</li><li>作为普通交换机时，显示Fail_mode是Standalone。其和物理交换机工作模式一样，记录端口号和MAC地址的对应关系，基于对应关系转发数据帧。交换机默认状态是SDN交换机。</li></ul><p>OVS 架构分为三个部分:</p><ul><li>内核空间：包含了流表（Flow Table）和Datapath模块（类似于网桥，主要负责对数据分组进行操作）。</li><li>用户空间：运行着OVS的守护进程(Open vSwitch Daemon, vswitchd)和数据库(Open vSwitch Database, ovsdb)，他们是ovs的核心功能模块。<ul><li>vswitchd类似于OVS的心脏，维持OVS的声明周期。可以配置一系列特性：<ul><li>基于MAC地址学习的二层交换</li><li>支持IEEE802.1Q VLAN</li><li>sFlow监测</li><li>连接OpenFlow控制器</li><li>通过Netlink协议与内核模块Datapath直接通信</li></ul></li><li>ovsdb相当于OVS的大脑，存储OVS的配置信息和数据流信息。</li></ul></li><li>配置管理层：包括ovs-dpctl, ovs-ofctl, ovs-appctl, ovs-vsctl和ovsdb-tool等，主要用于和vswitchd,ovsdb之间进行交互操作以及ovs的安装配置和部署</li></ul><p><img src="https://ganshizhong.gitee.io/blogimages/SDN/ovs%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png" alt="ovs 系统架构" /></p><h2 id="3-ovs安装使用"><a class="markdownIt-Anchor" href="#3-ovs安装使用"></a> 3. OVS安装使用</h2><p>OVS可以运行在任何基于Linux的虚拟化平台，包括KVM, VirtualBox, Xen等，其代码都是基于C编写，所以易于移植到其他环境。安装有两种方法：一种通过二进制文件安装apt-get；另外一种是源码安装。</p><h3 id="31-ovs安装"><a class="markdownIt-Anchor" href="#31-ovs安装"></a> 3.1 ovs安装</h3><p>docker 安装参见【<a href="/2021/04/26/Docker/docker_install">Ubuntu安装Docker与最常用配置</a>】</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu</span><br><span class="line">docker run -it --name ovs1 ubuntu /bin/bash</span><br><span class="line">  </span><br><span class="line">apt install python</span><br><span class="line">apt install python-pip</span><br><span class="line">wget https://www.openvswitch.org/releases/openvswitch-2.13.3.tar.gz</span><br><span class="line"></span><br><span class="line">参考：https://www.cnblogs.com/goldsunshine/p/10331606.html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">apt list --upgradable <span class="comment"># 查看可以升级的包</span></span><br><span class="line"></span><br><span class="line">apt install python</span><br><span class="line"></span><br><span class="line">apt install python-pip </span><br><span class="line"></span><br><span class="line">wget https://www.openvswitch.org/releases/openvswitch-2.13.3.tar.gz</span><br><span class="line"></span><br><span class="line">tar -zxf openvswitch-2.13.3.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">## 以下需root用户下执行</span></span><br><span class="line">./configure</span><br><span class="line">make </span><br><span class="line">make install</span><br><span class="line">make modules_install </span><br><span class="line">/sbin/modprobe openvswitch </span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/share/openvswitch/scripts</span><br><span class="line">ovs-ctl start </span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/share/openvswitch/scripts</span><br><span class="line">ovs-ctl --no-ovs-vswitchd start</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/share/openvswitch/scripts</span><br><span class="line">ovs-ctl --no--ovsdb-server start</span><br><span class="line"></span><br><span class="line">mkdir -p /usr/<span class="built_in">local</span>/etc/openvswitch</span><br><span class="line">ovsdb-tool create /usr/<span class="built_in">local</span>/etc/openvswitch/conf.db \</span><br><span class="line">    vswitchd/vswitch.ovsschema</span><br><span class="line"></span><br><span class="line">mkdir -p /usr/<span class="built_in">local</span>/var/run/openvswitch</span><br><span class="line">ovsdb-server --remote=punix:/usr/<span class="built_in">local</span>/var/run/openvswitch/db.sock \</span><br><span class="line">    --remote=db:Open_vSwitch,Open_vSwitch,manager_options \</span><br><span class="line">    --private-key=db:Open_vSwitch,SSL,private_key \</span><br><span class="line">    --certificate=db:Open_vSwitch,SSL,certificate \</span><br><span class="line">    --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert \</span><br><span class="line">    --pidfile --detach --log-file</span><br><span class="line"></span><br><span class="line">ovs-vsctl --no-wait init</span><br><span class="line">ovs-vswitchd --pidfile --detach --log-file</span><br></pre></td></tr></table></figure><blockquote><p>note:进入容器后，若发现无法联网请参见文章【<a href="/2021/04/27/Docker/netdisconnected/">Docker容器内网络无法连接</a>】</p></blockquote><h3 id="32-ovs-vsctl-命令使用"><a class="markdownIt-Anchor" href="#32-ovs-vsctl-命令使用"></a> 3.2 ovs-vsctl 命令使用</h3><p>ovs-ovsctl命令是对交换机上网桥和端口等信息进行配置的命令。获取或者更改ovs-vswitchd的配置信息，此工具操作的时候会更新ovsdb-server中的数据库。下面的操作需要连接控制器，控制器的安装可以参考【<a href="/2021/05/31/SDN/SDN05_OpenDaylight/">OpenDaylight安装</a>】</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看网桥</span></span><br><span class="line">ovs-vsctl show</span><br><span class="line"></span><br><span class="line">393b60ce-7d82-41e0-bd78-2aa47e54c8d5</span><br><span class="line">    ovs_version: <span class="string">&quot;2.13.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 添加网桥</span></span><br><span class="line">ovs-vsctl add-br br-test</span><br><span class="line"></span><br><span class="line">393b60ce-7d82-41e0-bd78-2aa47e54c8d5</span><br><span class="line">    Bridge br-test</span><br><span class="line">        Port br-test</span><br><span class="line">            Interface br-test</span><br><span class="line">                <span class="built_in">type</span>: internal</span><br><span class="line">    ovs_version: <span class="string">&quot;2.13.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 绑定网卡，创建网桥后会默认创建同名的port，可以绑定机器存在的网卡</span></span><br><span class="line">ovs-vsctl add-port br-test ens8</span><br><span class="line"></span><br><span class="line">393b60ce-7d82-41e0-bd78-2aa47e54c8d5</span><br><span class="line">    Bridge br-test</span><br><span class="line">        Port ens8</span><br><span class="line">            Interface ens8</span><br><span class="line">        Port br-test</span><br><span class="line">            Interface br-test</span><br><span class="line">                <span class="built_in">type</span>: internal</span><br><span class="line">    ovs_version: <span class="string">&quot;2.13.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 删除port绑定的网卡</span></span><br><span class="line">ovs-vsctl del-port br-test ens8</span><br><span class="line"><span class="comment">## 删除网桥</span></span><br><span class="line">ovs-vsctl add-br br-test</span><br><span class="line"><span class="comment">## 网桥连接控制器</span></span><br><span class="line">ovs-vsctl set-controller br-test tcp:x.x.x.x:6633</span><br><span class="line"><span class="comment">## 设置协议,否则web界面无法显示</span></span><br><span class="line">ovs-vsctl <span class="built_in">set</span> bridge br-test protocols=OpenFlow10</span><br><span class="line"></span><br><span class="line">393b60ce-7d82-41e0-bd78-2aa47e54c8d5</span><br><span class="line">    Bridge br-test</span><br><span class="line">        Controller <span class="string">&quot;tcp:x.x.x.x:6633&quot;</span></span><br><span class="line">            is_connected: <span class="literal">true</span></span><br><span class="line">        Port ens8</span><br><span class="line">            Interface ens8</span><br><span class="line">        Port br-test</span><br><span class="line">            Interface br-test</span><br><span class="line">                <span class="built_in">type</span>: internal</span><br><span class="line">    ovs_version: <span class="string">&quot;2.13.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 网桥端开连接控制器</span></span><br><span class="line">ovs-vsctl del-controller br-test</span><br></pre></td></tr></table></figure><p>ovs连接控制器成功后，可在opendaylight界面看到：</p><p><img src="https://ganshizhong.gitee.io/blogimages/SDN/ovs/ovs_odl.png" alt="ovs-odl" /></p><p>ovs连接本地docker容器后，可以在OpenDaylight界面看到：</p><p><img src="https://ganshizhong.gitee.io/blogimages/SDN/ovs/ovs_docker_odl.png" alt="ovs-odl" /></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 查看docker容器的网卡物理地址</span></span><br><span class="line">docker <span class="built_in">exec</span> -it h0 bash</span><br><span class="line">root@8cfaf3984bdf:/<span class="comment"># ifconfig</span></span><br><span class="line">eth0 flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1450</span><br><span class="line">        inet 10.0.50.10  netmask 255.255.255.0  broadcast 10.0.50.255</span><br><span class="line">        ether 02:42:0a:00:32:0a  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 2873  bytes 319842 (319.8 KB)</span><br><span class="line">        RX errors 0  dropped 2736  overruns 0  frame 0</span><br><span class="line">        TX packets 29  bytes 1666 (1.6 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p><strong>ovs连接容器方法有诸多坑存在，将单独整理一篇文章讲解</strong></p><p>上面说到，创建桥的时候会创建一个和桥名字一样的接口，并自动作为该桥的一个端口，那么这个虚拟接口的作用，一方面是可以作为交换机的管理端口，另一方面也是基于这个虚拟接口实现了桥的功能。Open vSwitch的内核模块实现了多个“数据路径”，每个都可以有多个vports。每个数据路径也通过关联流表（flow table）来设置操作，而这些流表中的流都是用户空间在报文头和元数据的基础上映射的关键信息，一般的操作都是将数据包转发到另一个vport。当一个数据包到达一个vport，内核模块所做的处理是提取其流的关键信息并在流表中查找这些关键信息，当有一个匹配的流时它执行对应的操作，如果没有匹配，它会将数据包送到用户空间的处理队列中，作为处理的一部分，用户空间可能会设置一个流用于以后碰到相同类型的数据包可以在内核中执行操作。<br />ovs-vsctl关于网桥管理的常用命令如下：</p><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>init</td><td>初始化数据库（前提数据分组为空）</td></tr><tr><td>show</td><td>打印数据库信息摘要</td></tr><tr><td>add-br BRIDGE</td><td>添加新的网桥</td></tr><tr><td>del-br BRIDGE</td><td>删除网桥</td></tr><tr><td>list-br</td><td>打印网桥摘要信息</td></tr><tr><td>list-ports BRIDGE</td><td>打印网桥中所有port摘要信息</td></tr><tr><td>add-port BRIDGE PORT</td><td>向网桥中添加端口</td></tr><tr><td>del-port [BRIDGE] PORT</td><td>删除网桥上的端口</td></tr><tr><td>get-controller BRIDGE</td><td>获取网桥的控制器信息</td></tr><tr><td>del-controller BRIDGE</td><td>删除网桥的控制器信息</td></tr><tr><td>set-controller BRIDGE TARGET</td><td>向网桥添加控制器</td></tr></tbody></table><h3 id="33-ovs-ofctl-命令使用"><a class="markdownIt-Anchor" href="#33-ovs-ofctl-命令使用"></a> 3.3 ovs-ofctl 命令使用</h3><p>ovs-ofctl 命令是对流表的操作，包括对流表的增，删，改，查等命令。简单来说流表类似于交换机的MAC地址表，路由器的路由表，是ovs交换机指挥流量转发的表。</p><p>OpenFlow是用于管理交换机流表的协议，ovs-ofctl是Open vSwitch提供的命令行工具。在没有配置OpenFlow控制器的模式下，用户可以使用ovs-ofctl命令通过OpenFlow协议连接Open vSwitch来创建、修改或删除Open vSwitch中的流表项，并对Open vSwitch的运行状况进行动态监控。ovs-ofctl关于流表管理的常用命令如下表所示：</p><p><img src="https://ganshizhong.gitee.io/blogimages/SDN/ovs/ovs-ofctl-commands.png" alt="ovs-ofctl命令" /></p><p>对于add-flow、add-flows和mod-flows这3个命令，还需要指定要执行的动作actions=[target],[target]…，一个流规则中可能有多个动作，按照指定的先后顺序执行。<br />常见的流表操作如下表所示</p><p><img src="https://ganshizhong.gitee.io/blogimages/SDN/ovs/flow_actions.png" alt="流表操作" /></p><p>在OpenFlow白皮书中，Flow被定义为某个特定的网络流量。例如，一个TCP连接就是一个Flow，或者从某个IP地址发出来的数据包，都可以被认为是一个Flow。支持OpenFlow协议的交换机应该包括一个或多个流表，流表中的条目包含：数据包头的信息、匹配成功后要执行的指令和统计信息。当数据包进入OVS后，会将数据包和流表中的流表项进行匹配，如果发现了匹配的流表项，则执行该流表项中的指令集。相反，如果数据包在流表中没有发现任何匹配，OVS会通过控制通道把数据包发到OpenFlow控制器中。在OVS中，流表项作为ovs-ofctl的参数，采用如下的格式：字段=值，如果有多个字段，可以用逗号或空格分开，一些常用的字段列举如下表所示。</p><p><img src="https://ganshizhong.gitee.io/blogimages/SDN/ovs/flow_paramter.png" alt="ovs-ofctl参数" /></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;SDN学习目录&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;/2021/04/09/SDN/SDN00_wireshark/&quot;&gt;SDN学习笔记(0)–wireshark抓包分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/2021/04</summary>
      
    
    
    
    <category term="SDN" scheme="http://shizhonggan.github.io/categories/SDN/"/>
    
    
    <category term="网络架构" scheme="http://shizhonggan.github.io/tags/%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84/"/>
    
    <category term="SDN" scheme="http://shizhonggan.github.io/tags/SDN/"/>
    
    <category term="OVS" scheme="http://shizhonggan.github.io/tags/OVS/"/>
    
  </entry>
  
  <entry>
    <title>软件定义网络（SDN）学习笔记(3)--Scapy交互式数据处理与Postman HTTP请求测试</title>
    <link href="http://shizhonggan.github.io/2021/04/20/SDN/SDN02_Scapy_Postman/"/>
    <id>http://shizhonggan.github.io/2021/04/20/SDN/SDN02_Scapy_Postman/</id>
    <published>2021-04-20T01:15:22.000Z</published>
    <updated>2021-06-04T08:00:11.637Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SDN学习目录</p><blockquote><p><a href="/2021/04/09/SDN/SDN00_wireshark/">SDN学习笔记(0)–wireshark抓包分析</a></p><p><a href="/2021/04/15/SDN/SDN01_iPerf_Netperf/">SDN学习笔记(1)–iPerf和Netperf性能测试</a></p><p><a href="/2021/04/20/SDN/SDN02_Scapy_Postman/">SDN学习笔记(2)–Scapy交互式数据处理与Postman HTTP请求测试</a></p><p><a href="/2021/04/21/SDN/SDN03_ovs/">SDN学习笔记(3)–OVS系统架构</a></p><p><a href="/2021/05/31/SDN/SDN05_OpenDaylight/">SDN学习笔记(5)–OpenDaylight控制器</a></p></blockquote></blockquote><h2 id="Scapy"><a href="#Scapy" class="headerlink" title="Scapy"></a>Scapy</h2><p>Scapy 是基于python编写的交互式数据包处理程序，使用pyhon解释器作为命令面板。可以用来发送、嗅探、解析和伪造网络数据包，通常用于网络攻击和测试。</p><p>Scapy 不仅可以实现扫描、路由跟踪、探测、单元测试、攻击和发现网络等传统功能，也可以代替hping、arpspoof、arp-sk、arping、p0f,实现部分Namp、Tcpdump和tshark的功能。</p><p>它能够伪造或解码大量的网络协议数据包，能够发送、捕捉、匹配请求和回复包等。</p><p>它还可以发送无效数据帧、诸如修改的802.11数据帧、在WEP熵解码加密通道(VOIP)、ARP缓存攻击(VLAN)等，这是其他工具无法完成的。</p><p>Scapy主要负责定义、发送和接收报文。</p><h2 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h2><p>Postman是google开发的一款强大的王爷调试、发送网页HTTP请求，并能运行测试用例的Chrome插件。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;SDN学习目录&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;/2021/04/09/SDN/SDN00_wireshark/&quot;&gt;SDN学习笔记(0)–wireshark抓包分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/2021/04</summary>
      
    
    
    
    <category term="SDN" scheme="http://shizhonggan.github.io/categories/SDN/"/>
    
    
    <category term="Scapy" scheme="http://shizhonggan.github.io/tags/Scapy/"/>
    
    <category term="Postman" scheme="http://shizhonggan.github.io/tags/Postman/"/>
    
  </entry>
  
  <entry>
    <title>MYSQL游标使用方法</title>
    <link href="http://shizhonggan.github.io/2021/04/19/SQL/mysql_cursor/"/>
    <id>http://shizhonggan.github.io/2021/04/19/SQL/mysql_cursor/</id>
    <published>2021-04-19T03:18:43.247Z</published>
    <updated>2021-04-19T08:40:33.359Z</updated>
    
    <content type="html"><![CDATA[<h2 id="游标"><a class="markdownIt-Anchor" href="#游标"></a> 游标</h2><p>游标的特性</p><ul><li>不敏感：数据库可以选择不复制结果集</li><li>只读</li><li>不滚动：游标只能向一方向前进，并且不可以跳过任何一行数据</li></ul><p>游标的优点</p><ul><li>游标是针对行操作的，对从数据库中 select 查询得到的结果集的 每一行可以</li><li>进行分开的独立的相同或者不相同的操作，是一种分离的思想。</li></ul><p>游标的缺点</p><ul><li>性能不高</li><li>只能一行一行操作</li><li>使用游标会产生死锁，造成内存开销大</li></ul><p>游标的适用场景</p><ul><li>存储过程</li><li>函数</li><li>触发器</li><li>事件</li></ul><h2 id="游标使用方法"><a class="markdownIt-Anchor" href="#游标使用方法"></a> 游标使用方法</h2><p>游标五步法：</p><ul><li>一、声明一个游标:<ul><li>DECLARE cursor_name CURSOR FOR select_statement 这个语句声明一个游标。也可以在子程序中定义多个游标，一个块中的每一个游标必须命名唯一。声明游标后也是单条操作的。</li></ul></li><li>二、打开定义的游标:<ul><li>OPEN cursor_name 这个语句打开先前声明的游标。</li></ul></li><li>三、获得下一行数据:<ul><li>FETCH cursor_name INTO var_name [, var_name] … 这个语句用指定的打开游标读取下一行（如果有下一行的话），并且前进游标指针至该行。</li></ul></li><li>四、需要执行的语句(增删改查):这里视具体情况而定</li><li>五、释放游标:<ul><li>CLOSE cursor_name 这个语句关闭先前打开的游标，注意，用完后必须关闭。</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span> UpdateImgURL;</span><br><span class="line"><span class="comment">/***游标***/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> UpdateImgURL()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"> <span class="comment">-- 遍历数据结束标志</span></span><br><span class="line"><span class="keyword">DECLARE</span> Done <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> Imgurl <span class="type">CHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> &quot;&quot;;</span><br><span class="line"><span class="comment">-- 游标</span></span><br><span class="line"><span class="keyword">DECLARE</span> RS <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> imgurl <span class="keyword">FROM</span> weixin_linkface_userinfo ;</span><br><span class="line"><span class="comment">-- 异常处理</span></span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;02000&#x27;</span> <span class="keyword">SET</span> Done <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 打开游标</span></span><br><span class="line"><span class="keyword">OPEN</span> RS;</span><br><span class="line"><span class="keyword">FETCH</span> NEXT <span class="keyword">FROM</span> RS <span class="keyword">INTO</span> Imgurl;</span><br><span class="line">REPEAT</span><br><span class="line">IF <span class="keyword">NOT</span> Done <span class="keyword">THEN</span></span><br><span class="line"><span class="comment">/**update 表名 set 字段名=REPLACE (字段名,&#x27;原来的值&#x27;,&#x27;要修改的值&#x27;)  where 条件  **/</span></span><br><span class="line"><span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">FETCH</span> NEXT <span class="keyword">FROM</span> RS <span class="keyword">INTO</span> Imgurl;</span><br><span class="line">UNTIL Done <span class="keyword">END</span> REPEAT;</span><br><span class="line"><span class="keyword">CLOSE</span> rs;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"><span class="comment">/**执行存储过程**/</span></span><br><span class="line"><span class="keyword">CALL</span> UpdateImgURL</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"> <span class="keyword">DECLARE</span>  no_more_record <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">DECLARE</span>  pID <span class="type">BIGINT</span>(<span class="number">20</span>);</span><br><span class="line"> <span class="keyword">DECLARE</span>  pValue <span class="type">DECIMAL</span>(<span class="number">15</span>,<span class="number">5</span>);</span><br><span class="line"> <span class="keyword">DECLARE</span>  cur_record <span class="keyword">CURSOR</span> <span class="keyword">FOR</span>   <span class="keyword">SELECT</span> colA, colB <span class="keyword">from</span> tableABC;  <span class="comment">/*首先这里对游标进行定义*/</span></span><br><span class="line"> <span class="keyword">DECLARE</span>  CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND  <span class="keyword">SET</span>  no_more_record <span class="operator">=</span> <span class="number">1</span>; <span class="comment">/*这个是个条件处理,针对NOT FOUND的条件,当没有记录时赋值为1*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="keyword">OPEN</span>  cur_record; <span class="comment">/*接着使用OPEN打开游标*/</span></span><br><span class="line"> <span class="keyword">FETCH</span>  cur_record <span class="keyword">INTO</span> pID, pValue; <span class="comment">/*把第一行数据写入变量中,游标也随之指向了记录的第一行*/</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> WHILE no_more_record <span class="operator">!=</span> <span class="number">1</span> DO</span><br><span class="line"> <span class="keyword">INSERT</span>  <span class="keyword">INTO</span> testTable(ID, <span class="keyword">Value</span>)</span><br><span class="line"> <span class="keyword">VALUES</span>  (pID, pValue);</span><br><span class="line"> <span class="keyword">FETCH</span>  cur_record <span class="keyword">INTO</span> pID, pValue;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">END</span> WHILE;</span><br><span class="line"> <span class="keyword">CLOSE</span>  cur_record;  <span class="comment">/*用完后记得用CLOSE把资源释放掉*/</span></span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;游标&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#游标&quot;&gt;&lt;/a&gt; 游标&lt;/h2&gt;
&lt;p&gt;游标的特性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不敏感：数据库可以选择不复制结果集&lt;/li&gt;
&lt;li&gt;只读&lt;/li&gt;
&lt;li&gt;不滚动：游标只能向一方向前进</summary>
      
    
    
    
    <category term="SQL" scheme="http://shizhonggan.github.io/categories/SQL/"/>
    
    
    <category term="游标" scheme="http://shizhonggan.github.io/tags/%E6%B8%B8%E6%A0%87/"/>
    
  </entry>
  
  <entry>
    <title>Keras学习准备[待续...]</title>
    <link href="http://shizhonggan.github.io/2021/04/17/DeepLeaning/Keras/KerasBase/"/>
    <id>http://shizhonggan.github.io/2021/04/17/DeepLeaning/Keras/KerasBase/</id>
    <published>2021-04-17T07:54:23.000Z</published>
    <updated>2021-04-26T06:11:14.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-安装"><a class="markdownIt-Anchor" href="#1-安装"></a> 1. 安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip install tensorflow</span><br><span class="line">pip install tensorflow-gpu</span><br><span class="line">pip install keras</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 其他</span></span></span><br><span class="line">pip install pydot pydot_ng  vizgraph python3-tk matplotlib</span><br></pre></td></tr></table></figure><h2 id="2-主要模型"><a class="markdownIt-Anchor" href="#2-主要模型"></a> 2. 主要模型</h2><ol><li>MLP(多层感知机)<ul><li>全连接网络，也成为深度前馈网络或前馈神经网络。常用于简单的逻辑和线性回归问题。处理序列数据和多维数据欠佳。</li></ul></li><li>CNN(卷积神经网络)<ul><li>主要应用与图像或视频的分类、分割和生成等。也可用于时序数据网络</li></ul></li><li>RNN(循环神经网络)<ul><li>主要应用于序列数据的预测</li></ul></li></ol><h2 id="3-代码流程"><a class="markdownIt-Anchor" href="#3-代码流程"></a> 3. 代码流程</h2><h3 id="31-加载数据集"><a class="markdownIt-Anchor" href="#31-加载数据集"></a> 3.1 加载数据集</h3><p>数据集常用MNIST手写体</p><h2 id="3-mlp"><a class="markdownIt-Anchor" href="#3-mlp"></a> 3. MLP</h2><ul><li>数据集 MNIST手写体</li></ul><p>代码：<a href="https://github.com/PacktPublishing/Advanced-Deep-Learning-with-Keras">https://github.com/PacktPublishing/Advanced-Deep-Learning-with-Keras</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-安装&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-安装&quot;&gt;&lt;/a&gt; 1. 安装&lt;/h2&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="Deep Learning" scheme="http://shizhonggan.github.io/categories/Deep-Learning/"/>
    
    
  </entry>
  
  <entry>
    <title>软件定义网络（SDN）学习笔记(1)--iPerf和Netperf性能测试</title>
    <link href="http://shizhonggan.github.io/2021/04/15/SDN/SDN01_iPerf_Netperf/"/>
    <id>http://shizhonggan.github.io/2021/04/15/SDN/SDN01_iPerf_Netperf/</id>
    <published>2021-04-15T08:15:22.000Z</published>
    <updated>2021-06-04T08:00:06.546Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SDN学习目录</p><blockquote><p><a href="/2021/04/09/SDN/SDN00_wireshark/">SDN学习笔记(0)–wireshark抓包分析</a></p><p><a href="/2021/04/15/SDN/SDN01_iPerf_Netperf/">SDN学习笔记(1)–iPerf和Netperf性能测试</a></p><p><a href="/2021/04/20/SDN/SDN02_Scapy_Postman/">SDN学习笔记(2)–Scapy交互式数据处理与Postman HTTP请求测试</a></p><p><a href="/2021/04/21/SDN/SDN03_ovs/">SDN学习笔记(3)–OVS系统架构</a></p><p><a href="/2021/05/31/SDN/SDN05_OpenDaylight/">SDN学习笔记(5)–OpenDaylight控制器</a></p></blockquote></blockquote><h2 id="1-iPerf-and-Netperf"><a href="#1-iPerf-and-Netperf" class="headerlink" title="1. iPerf and Netperf"></a>1. iPerf and Netperf</h2><p>iPerf是网络性能测试工具，可以测试主机之间的吞吐量。iPerf具有多种参数和特性，支持协议、定时、缓冲区等参数的配置调整，能够测试TCP/UDP的最大带宽、延迟抖动、数据包丢失等统计信息。iPerf基于Server/Client的工作模式,客户端向服务端发送一定量的数据，服务端统计并计算带宽、延时和抖动等信息。</p><ul><li>命令格式： iperf [-s|-c host] [options]</li></ul><p>Netperf也是网络性能测试工具，主要用于测试TCP或UDP和Berkeley套接字接口的批量数据传输(Bulk Data Transfer)和请求/应答(Request/Reponse)性能。Netperf工具以Client/Server方式工作，服务端是netServer，用来侦听来自客户端的连接，客户端时NetPerf，用来向服务发起网络测试。在客户端与服务端之间，首先建立一个控制连接，传递有关测试配置的信息，以及测试的结果。在控制连接建立并传递了测试配置信息以后，客户端与服务之间建立一个测试连接，用于来回传递特殊的流量，已测试网络性能。</p><ul><li>命令格式：netperf [global options] –[test-specific options]</li></ul><h2 id="2-性能测试指标"><a href="#2-性能测试指标" class="headerlink" title="2. 性能测试指标"></a>2. 性能测试指标</h2><ol><li>网络吞吐量：单位时间内通过某个网络(信道或接口)的数据量，吞吐量受网络的带宽或网络的额定速率限制，单位bit/s</li><li>网络延时：一个数据包从用户的计算机发送到网站服务器，然后立即从网站服务器返回用户计算机的来回时间。影响网络演示的主要因素：路由的跳数和网络的流量。交换机延时(Latency)是指从交换机接收到数据包到开始向目的端口复制数据包之间的时间间隔。有许多因素会影响交换机演示大小，如转发技术等。</li><li>抖动：用于描述包在网络中的传输延时变化，抖动越小，说明网络质量越稳定、越好。</li><li>丢包率：理想状态下发送多少数据包就能接收到多少数据包。但由于信号衰减、网络质量等诸多因素的影响并不能达到理想状态。丢包率是指测试中多丢失的数据包数量占所有发送数据包的比率。</li></ol><h2 id="3-iPerf和Netperf比较"><a href="#3-iPerf和Netperf比较" class="headerlink" title="3. iPerf和Netperf比较"></a>3. iPerf和Netperf比较</h2><table><thead><tr><th>比较项</th><th>iPerf</th><th>Netperf</th></tr></thead><tbody><tr><td>支持多线程</td><td>是</td><td>是</td></tr><tr><td>可以设置服务器关闭之前保持的连接数</td><td>是</td><td>否</td></tr><tr><td>支持组播</td><td>是</td><td>否</td></tr><tr><td>支持除TCP,UDP之外的协议</td><td>否</td><td>是</td></tr><tr><td>支持IPv6</td><td>一定程度上</td><td>是</td></tr><tr><td>可以输出TCP MSS指</td><td>是</td><td>否</td></tr><tr><td>设置测试分组大小</td><td>否</td><td>是</td></tr><tr><td>支持多种测试范式</td><td>否</td><td>是</td></tr></tbody></table><h2 id="4-测试命令"><a href="#4-测试命令" class="headerlink" title="4. 测试命令"></a>4. 测试命令</h2><h3 id="4-1-iPerf"><a href="#4-1-iPerf" class="headerlink" title="4.1 iPerf"></a>4.1 iPerf</h3><h4 id="一、TCP测试"><a href="#一、TCP测试" class="headerlink" title="一、TCP测试"></a>一、TCP测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 主机一 10.0.0.8</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iperf -s <span class="comment"># 作为服务端</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 主机二</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iperf -c 10.0.0.8</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iperf -c 10.0.0.8 -t 32 -i 8 <span class="comment"># 测试时间32s,输出频率8s</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iperf -c 10.0.0.8 -n 2000M -i 5 <span class="comment"># 数据包为2000M,输出频率5s</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 主机三 与主机二 分别执行上述命令，可以观察主机一的测试结果， 不同时段的带宽相差比较大</span></span></span><br></pre></td></tr></table></figure><h4 id="二、UDP测试"><a href="#二、UDP测试" class="headerlink" title="二、UDP测试"></a>二、UDP测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 主机一 10.0.0.8 停止iPerf TCP服务</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iperf -s -u <span class="comment"># UDP测试</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iperf -c 10.0.0.8 -u -b 2000M -i 5 -l 1380 <span class="comment"># -b 2000M 2000Mbit/s发送速率， -i 5 表示输出频率5s -l 1380表示数据包的大小为1380个字节</span></span></span><br></pre></td></tr></table></figure><blockquote><p>note: 若发现Server接收不到Client 端发来的包，即没有任何输出，请检查是不是Client 端发的数据包大小大于Server端网卡设置的MTU值。当不设置-l的时候，Client端默认发送的数据包大小为1470.</p></blockquote><h3 id="4-2-Netperf"><a href="#4-2-Netperf" class="headerlink" title="4.2 Netperf"></a>4.2 Netperf</h3><h4 id="一、TCP测试-1"><a href="#一、TCP测试-1" class="headerlink" title="一、TCP测试"></a>一、TCP测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 主机一</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> netserver -p 9991 <span class="comment"># 指定端口</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 主机二</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> netperf -H 10.0.0.8 -p 9991 <span class="comment"># 缺省TCP批量传输，即 -t TCP_STREAM</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> netperf -H 10.0.0.8 -p 9991 -- -m 1024</span></span><br></pre></td></tr></table></figure><h4 id="二、UDP-测试"><a href="#二、UDP-测试" class="headerlink" title="二、UDP 测试"></a>二、UDP 测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netperf -t UDP_STREAM -H 10.0.0.8 -p 9991 -- -m 1024</span></span><br></pre></td></tr></table></figure><blockquote><p>note: 不同于iPerf, Netperf测试UDP数据包无需在服务器端指定参数，所以，不用重启服务器，只需要在客户端上加上 -t UDP_STREAM</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;SDN学习目录&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;/2021/04/09/SDN/SDN00_wireshark/&quot;&gt;SDN学习笔记(0)–wireshark抓包分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/2021/04</summary>
      
    
    
    
    <category term="SDN" scheme="http://shizhonggan.github.io/categories/SDN/"/>
    
    
    <category term="性能测试" scheme="http://shizhonggan.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="iPerf" scheme="http://shizhonggan.github.io/tags/iPerf/"/>
    
    <category term="Netperf" scheme="http://shizhonggan.github.io/tags/Netperf/"/>
    
  </entry>
  
  <entry>
    <title>[阅读] Few-Shot Adversarial Domain Adaptation</title>
    <link href="http://shizhonggan.github.io/2021/04/14/Paper/Few-ShotAdversarialDomainAdaptation/"/>
    <id>http://shizhonggan.github.io/2021/04/14/Paper/Few-ShotAdversarialDomainAdaptation/</id>
    <published>2021-04-14T13:54:23.000Z</published>
    <updated>2021-04-16T00:42:51.206Z</updated>
    
    <content type="html"><![CDATA[<p>参考资料：</p><p>Github Code: <a href="https://github.com/Coolnesss/fada-pytorch">https://github.com/Coolnesss/fada-pytorch</a>[作者源程序]</p><p>Github Code: <a href="https://github.com/xzsl/FewShotPapers">https://github.com/xzsl/FewShotPapers</a>[源程序，包含数据源，参考文献]</p><p><a href="http://blog.leanote.com/post/wuvin/1f36d3173608">http://blog.leanote.com/post/wuvin/1f36d3173608</a></p><p><a href="https://blog.csdn.net/Adupanfei/article/details/85164925">https://blog.csdn.net/Adupanfei/article/details/85164925</a></p><p><a href="https://github.com/topics/domain-adaptation">https://github.com/topics/domain-adaptation</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;Github Code: &lt;a href=&quot;https://github.com/Coolnesss/fada-pytorch&quot;&gt;https://github.com/Coolnesss/fada-pytorch&lt;/a&gt;[作者源程序]&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="Deep Learning" scheme="http://shizhonggan.github.io/categories/Deep-Learning/"/>
    
    
    <category term="Few-shot Learning" scheme="http://shizhonggan.github.io/tags/Few-shot-Learning/"/>
    
    <category term="Semi-Supervised Learning" scheme="http://shizhonggan.github.io/tags/Semi-Supervised-Learning/"/>
    
  </entry>
  
  <entry>
    <title>软件定义网络（SDN）学习笔记(0)--wireshark抓包分析</title>
    <link href="http://shizhonggan.github.io/2021/04/09/SDN/SDN00_wireshark/"/>
    <id>http://shizhonggan.github.io/2021/04/09/SDN/SDN00_wireshark/</id>
    <published>2021-04-09T07:36:22.000Z</published>
    <updated>2021-06-04T07:59:58.359Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>SDN学习目录</p><blockquote><p><a href="/2021/04/09/SDN/SDN00_wireshark/">SDN学习笔记(0)–wireshark抓包分析</a></p><p><a href="/2021/04/15/SDN/SDN01_iPerf_Netperf/">SDN学习笔记(1)–iPerf和Netperf性能测试</a></p><p><a href="/2021/04/20/SDN/SDN02_Scapy_Postman/">SDN学习笔记(2)–Scapy交互式数据处理与Postman HTTP请求测试</a></p><p><a href="/2021/04/21/SDN/SDN03_ovs/">SDN学习笔记(3)–OVS系统架构</a></p><p><a href="/2021/05/31/SDN/SDN05_OpenDaylight/">SDN学习笔记(5)–OpenDaylight控制器</a></p></blockquote></blockquote><h2 id="简单网络命令"><a href="#简单网络命令" class="headerlink" title="简单网络命令"></a>简单网络命令</h2><h3 id="1-ifconfig"><a href="#1-ifconfig" class="headerlink" title="1. ifconfig"></a>1. ifconfig</h3><p>ifconfig用于显示、设置、启动和停止网络设备。通过此命令能够显示出正在使用的计算机的IP地址、子网掩码和默认网关等。当网络环境发生改变时可通过此命令对网络进行相应的配置。ifconfig命令的格式和参数解释如下：</p><ul><li>命令格式：ifconfig [网络设备] [参数]</li><li>命令参数如下表所示：</li></ul><p><img src="https://ganshizhong.gitee.io/blogimages/SDN/NetTools/ifconfig.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ifconfig <span class="comment"># 查看网络设备信息</span></span></span><br><span class="line">eth0      Link encap:Ethernet  HWaddr fa:16:3e:22:f1:7c  </span><br><span class="line">          inet addr:30.0.0.96  Bcast:30.0.0.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::f816:3eff:fe22:f17c/64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1450  Metric:1</span><br><span class="line">          RX packets:2402 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:2390 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:190993 (190.9 KB)  TX bytes:4116702 (4.1 MB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1/128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:16 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:16 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:880 (880.0 B)  TX bytes:880 (880.0 B)</span><br><span class="line">eth0表示第一块网卡。</span><br><span class="line">HWaddr表示网卡的物理地址即MAC地址。</span><br><span class="line">inet addr表示网卡的IPv4地址。</span><br><span class="line">inet6 addr表示网卡的IPv6地址。</span><br><span class="line">Bcast表示网卡的广播地址。</span><br><span class="line">Mask表示子网掩码地址。</span><br><span class="line">UP表示网卡开启状态。</span><br><span class="line">RUNNING表示网卡的网线被接上。</span><br><span class="line">MULTICAST表示支持组播。</span><br><span class="line">MTU表示最大传输单元。</span><br><span class="line">RX packets、TX packets表示接收、发送数据包情况统计。</span><br><span class="line">RX byte、TX bytes表示接收、发送数据字节数统计信息。</span><br><span class="line">lo表示主机的回环地址。一般是用来测试一个网络程序时又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口，比如把httpd服务器指定到回坏地址后，在浏览器输入127.0.0.1就能看到你所架WEB网站，但只有您能看得到，局域网的其它主机或用户无从知道。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ifconfig eth0 down <span class="comment"># 关闭网卡</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ifconfig eth0 up <span class="comment"># 开启网卡</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ifconfig eth0 192.168.2.10 netmask 255.255.255.0 broadcast 192.168.2.255 <span class="comment"># 配置IP地址等信息</span></span></span><br></pre></td></tr></table></figure><blockquote><p>note: 机器重启后，配置的IP地址就失效了，若想将配置信息永久地存的电脑里，需要修改网卡的配置文件。</p></blockquote><h3 id="2-ping"><a href="#2-ping" class="headerlink" title="2. ping"></a>2. ping</h3><p>ping命令用于检查网络是否通畅和网络连接速度。简单地说，网络上的机器都有唯一确定的IP地址，给目标IP地址发送一个数据包，就会返回一个同样大小的数据包，根据返回的数据包可以确定目标主机是否存在，可以初步判断网络是否通畅以及连接速度等信息。根据数据包返回时间和丢包率，可以大致判断出网络是否稳定。Ping的返回异常信息有“Request Timed Out”、“Destination Net Unreachable”、“Bad IP address”和“Source quench received”：<br>（1） Request Timed Out表示对方主机可以到达但是连接超时，这种情况通常是对方拒绝接收你发给它的数据包而造成的数据包丢失。原因可能是对方装有防火墙。<br>（2） Destination Net Unreachable表示对方主机不存在或者没有跟对方建立连接。<br>（3） Bad IP address表示可能没有连接到DNS服务器所以无法解析这个IP地址，也可能是IP地址不存在。<br>（4） Source quench received表示对方或中途的服务器繁忙无法回应。<br>说明：“destination host unreachable”和“time out”的区别：如果所经过的路由器的路由表中具有到达目标的路由，而目标因为其它原因不可到达，这时候会出现“time out”，如果路由表中连到达目标的路由都没有，那就会出现“destination host unreachable”。<br>ping命令的格式和参数解释如下：</p><ul><li>命令格式：<br>ping [参数] [主机名或IP地址]</li><li>命令参数如下表所示：</li></ul><p><img src="https://ganshizhong.gitee.io/blogimages/SDN/NetTools/ping.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ping 127.0.0.1 <span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ping -c 5 www.xxx.com <span class="comment"># -c 5表示在发送5个数据包后停止。</span></span></span><br></pre></td></tr></table></figure><blockquote><p>note1: ping本网网关或本网IP地址，可以检查硬件设备是否有问题，也可以检查本机与本地网络连接是否正常（在非局域网中这一步骤可以忽略）。</p></blockquote><h3 id="3-traceroute命令"><a href="#3-traceroute命令" class="headerlink" title="3. traceroute命令"></a>3. traceroute命令</h3><p>traceroute是用来显示源主机到目标主机之间所经过的网关的命令。traceroute命令用IP生存时间（TTL）字段和ICMP错误消息来确定从一个主机到网络上其他主机的路由。首先，traceroute发送一个TTL是1的IP数据包到目的地，当路径上的第一个路由器收到这个数据包时，TTL将会减1。此时，TTL变为0，所以该路由器会将此数据包丢掉，并返回一个ICMP time exceeded消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址）。traceroute收到这个消息后，便知道这个路由器存在于路径上，接着traceroute再发送一个TTL是2的数据包，继而发现第2个路由器。依此规律，traceroute每次将发送的数据包的TTL加1来发现下一个路由器，一直持续到某个数据包抵达目的地。当数据包到达目的地后，该主机则不会返回ICMP time exceeded消息，此时traceroute通过UDP数据包向不常见端口（30000以上）发送数据包，因此会收到ICMP port unreachable消息，故可判断到达目的地。<br>traceroute命令的格式和参数解释如下：</p><ul><li>命令格式：<br>traceroute [参数] [主机]</li><li>命令参数如下表所示：</li></ul><p><img src="https://ganshizhong.gitee.io/blogimages/SDN/NetTools/traceroute.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sudo su</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> apt-get install traceroute <span class="comment"># 安装</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> traceroute www.baidu.com <span class="comment"># 追踪网络数据包的路由途径，执行结果如下图所示</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> traceroute -m 10 www.baidu.com <span class="comment"># 设置路由追踪10条，即只发回通过10个网关的信息</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> traceroute -w 3 www.baidu.com <span class="comment"># 把对外发探测包的等待响应时间设置为3秒</span></span></span><br></pre></td></tr></table></figure><h3 id="4-route命令"><a href="#4-route命令" class="headerlink" title="4. route命令"></a>4. route命令</h3><p>route用于显示和操作IP路由表，它的主要作用是创建静态路由。在Linux系统中，设置路由通常是为了解决以下问题：Linux系统在一个局域网中，局域网中有一个网关，若要让机器访问Internet，那么就需要将网关的IP地址设置为Linux机器的默认路由。route命令的格式和参数解释如下：</p><ul><li>命令格式：<br>route [-f] [-p] [command] [destination] [mask netmask] [gateway] [metric] [if interface]</li><li>命令参数如下表所示:</li></ul><p><img src="https://ganshizhong.gitee.io/blogimages/SDN/NetTools/traceroute.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> route</span></span><br><span class="line">openlab@openlab:~/Desktop$ route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">default         30.0.0.1        0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">default         30.0.0.1        0.0.0.0         UG    100    0        0 eth0</span><br><span class="line">30.0.0.0        *               255.255.255.0   U     0      0        0 eth0</span><br><span class="line">169.254.169.254 30.0.0.1        255.255.255.255 UGH   0      0        0 eth0</span><br></pre></td></tr></table></figure><ul><li>Destination：表示目标网段或主机。</li><li>Gateway：表示网关地址，“*”表示目标是本主机所属的网络，不需要路由。</li><li>Genmask：表示网络掩码。</li><li>Flags：表示标记。常用标记如下：<ul><li>U表示路由是活动的</li><li>H表示目标是一个主机</li><li>G表示路由指向网关</li><li>R表示恢复动态路由产生的表项</li><li>D表示由路由的后台程序动态地安装</li><li>M表示由路由的后台程序修改</li><li>！表示拒绝路由。</li></ul></li><li>Metric：表示路由距离，到达指定网络所需的中转数（Linux内核中没有使用）。</li><li>Ref：表示路由项引用次数（Linux内核中没有使用）。</li><li>Use：表示此路由项被路由软件查找的次数。</li><li>Iface：表示该路由表项对应的输出接口。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0 <span class="comment"># 添加网关</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> route del -net 224.0.0.0 netmask 240.0.0.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> route add -net 192.168.62.0 netmask 255.255.255.0 gw 192.168.1.1 <span class="comment"># 添加一条路由(发往192.168.62这个网段的全部要经过网关192.168.1.1)</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> route del -net 192.168.122.0 netmask 255.255.255.0 <span class="comment"># 删除一条路由　删除的时候不用写网关</span></span></span><br></pre></td></tr></table></figure><h3 id="5-IP"><a href="#5-IP" class="headerlink" title="5. IP"></a>5. IP</h3>ip命令用来显示或操纵Linux主机的路由、网络设备、策略路由和隧道，是Linux下较新的功能强大的网络配置工具。它能够替代一些传统的网络管理工具，例如ifconfig、route等，使用权限为超级用户，ip命令的格式和参数解释如下：</li><li>命令格式：<br>ip [OPTIONS] OBJECT [COMMAND [ARGUMENTS]]</li><li>命令参数：<br>OPTIONS是一些修改ip行为或者改变其输出的选项。所有的选项都是以-字符开头，分为长、短两种形式。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip link list <span class="comment"># 查看网络设备的运行状态</span></span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether fa:16:3e:50:89:7f brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure></li><li>lo表示主机的回环地址。</li><li>eth0表示第一块网卡。</li><li>UP表示网卡开启状态。</li><li>MULTICAST表示支持组播。</li><li>mtu表示最大传输单元。</li><li>link/ether表示MAC地址。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip -s link list <span class="comment"># 查看更加详细的网络设备信息</span></span></span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default </span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    RX: bytes  packets  errors  dropped overrun mcast   </span><br><span class="line">    880        16       0       0       0       0      </span><br><span class="line">    TX: bytes  packets  errors  dropped carrier collsns </span><br><span class="line">    880        16       0       0       0       0      </span><br><span class="line">2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether fa:16:3e:50:89:7f brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    RX: bytes  packets  errors  dropped overrun mcast   </span><br><span class="line">    378682     3605     0       0       0       0      </span><br><span class="line">    TX: bytes  packets  errors  dropped carrier collsns </span><br><span class="line">    2422264    2317     0       0       0       0 </span><br></pre></td></tr></table></figure></li><li>RX packets、TX packets表示接收、发送数据包情况统计。</li><li>RX bytes、TX bytes表示接收、发送数据字节数统计信息。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip addr list <span class="comment"># 查看ip信息</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ip link <span class="built_in">set</span> eth0 down <span class="comment"># ip link list命令</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ip link <span class="built_in">set</span> eth0 up <span class="comment"># 开启eth0网卡</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> route add default gw 30.0.1.1 <span class="comment"># 设置网关</span></span></span><br></pre></td></tr></table></figure></li><li>inet表示网卡的IPv4地址。</li><li>inet6表示网卡的IPv6地址。<blockquote><p>note: 使用ip命令关闭网卡后，默认路由也被删除了，而使用ip命令启用网卡时，并不会配置路由，所以将无法ping通公网地址，故需要配置路由。</p></blockquote></li></ul><h3 id="6-netstat命令"><a href="#6-netstat命令" class="headerlink" title="6. netstat命令"></a>6. netstat命令</h3><p>netstat是一个监控TCP/IP网络的非常有用的命令，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息。它用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。另外它还能列出处于监听状态（即等待接入请求）的套接字。如果你想确认系统上的Web服务有没有起来，你可以查看80端口有没有打开。netstat命令的格式和参数解释如下：</p><ul><li>命令格式：<br>netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][—ip]</li><li>命令参数如下表所示：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> netstat -a <span class="comment"># 查看所有端口信息</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> netstat -at <span class="comment"># 查看TCP连接</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> netstat -l <span class="comment"># 查看所有处于监听状态的Sockets</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> netstat -ap | grep ssh <span class="comment"># 查看程序运行的端口</span></span></span><br></pre></td></tr></table></figure><h3 id="7-tcpdump命令"><a href="#7-tcpdump命令" class="headerlink" title="7. tcpdump命令"></a>7. tcpdump命令</h3>tcpdump是根据使用者的定义对网络上的数据包进行截获的包分析工具。tcpdump凭借强大的功能和灵活的截取策略，成为类UNIX系统下用于网络分析和问题排查的首选工具。tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤。</li><li>命令格式：<br>tcpdump [ -adeflnNOpqStvx ] [ -c 数量 ] [ -F 文件名 ]<br>[ -i 网络接口 ] [ -r 文件名] [ -s snaplen ]<br>[ -T 类型 ] [ -w 文件名 ] [表达式 ]</li><li>命令参数：</li></ul><p>tcpdump命令常用参数如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> tcpdump -i eth0 <span class="comment"># 进行抓包</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ping www.xxxx.com <span class="comment"># 在打开一个窗口进行网络请求,可看到抓包信息</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tcpdump -i eth0 tcp port 80 <span class="comment"># 抓取端口为80的TCP协议的数据信息</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tcpdump-i eth0 tcp <span class="comment"># 抓取TCP协议的数据信息，并访问网址：www.xxx.com</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tcpdump -i eth0 -w tcpdump_package.pcap <span class="comment"># 该命令作用是将tcupdump抓到的网络包保存到tcpdump_package.pcap文件中，命名规则为：文件名.pcap。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> tcpdump -r tcpdump_package.pcap <span class="comment"># 该命令作用是将保存在tcpdump_package.pacp中的抓包信息读取出来。</span></span></span><br></pre></td></tr></table></figure><h3 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h3><p>下面（B）命令用于测试网络是否连通。</p><ul><li>A. ifconfig</li><li>B. ping</li><li>C. ftp</li><li>D. route</li></ul><p>下列相关route命令的使用错误的是（B）</p><ul><li>A. 添加路由：route add-net 192.168.1.0 netmask - 255.255.255.0 gw 192.168.1.1</li><li>B. 删除路由：route del-net 192.168.1.0</li><li>C. 添加默认网关：route add default gw 192.168.120.240</li><li>D. 添加路由：route add-net 192.168.1.0/24 dev eth0</li></ul><p>下面输出信息解释错误的是（D）</p><ul><li>A. HWaddr表示网卡的物理地址即MAC地址。</li><li>B. inet addr表示网卡的IP地址。</li><li>C. MTU表示最大传输单元。</li><li>D. RX packets、TX packets表示接收、发送数据字节数统计信息。</li></ul><p>判断： 使用ifconfig命令配置主机信息后，信息将永久保存在电脑里。×</p><p>判断： traceroute -m 4 <a href="http://www.xxx.com表示只发回通过4个网关的信息.√/">www.xxx.com表示只发回通过4个网关的信息。√</a></p><p>下列关于ip命令理解错误的是（B）</p><ul><li>A. ip命令用来显示或操纵Linux主机的路由、网络设备、策略路由和隧道，它能够替代一些传统的网络管理工具，例如ifconfig、route等。</li><li>B. ip命令支持的操作有add、delete、show和link。</li><li>C. 可以使用ip addr add 192.168.17.30/24 dev eth0命令给主机配置IP地址。</li><li>D. 使用ip命令的neighbour选项，可以查看接入你所在的局域网的设备的MAC地址。</li></ul><p>关于tcpdump命令理解错误的是（B）</p><ul><li>A. tcpdump支持对网络层、协议、主机、网络或端口的过滤。</li><li>B. tcpdump -i eth1 ‘((tcp) and (port 80) and ((dst host 192.168.1.254) or (dst host 192.168.1.200)))’，表示抓取所有经过eth1，目的地址是192.168.1.254和192.168.1.200，端口是80的TCP数据。</li><li>C. 不带任何选项的tcpdump，默认会抓取第一个网络接口，且只有将tcpdump进程终止才会停止抓包。</li><li>D. 表达式单元之间可以使用操作符” and / &amp;&amp; / or / || / not / ! “进行连接，从而组成复杂的条件表达式。</li></ul><p>下面对netstat的输出结果理解正确的是（D）</p><ul><li>A. Active Internet connections表示TCP连接；Active UNIX domain sockets表示Unix域套接口。</li><li>B. State：表示连接状态，LISTENING表示正在侦听端口，等待建立连接。</li><li>C. Proto：表示使用的通信协议。</li><li>D. 以上均正确</li></ul><p>判断： netstat是一个网络连接端扫描软件，用来扫描电脑上开放的端口，确定哪些服务运行在哪些端口，并且推断出计算机运行的操作系统。×</p><p>判断： 使用括号”()”可以改变tcpdump的表达式的优先级 √</p><h2 id="Wireshark抓包分析工具"><a href="#Wireshark抓包分析工具" class="headerlink" title="Wireshark抓包分析工具"></a>Wireshark抓包分析工具</h2><p>Wireshark是一个免费开源的网络数据包分析软件。用于截取网络数据包并尽可能显示出最为详细的网络数据包数据。为了安全考虑，Wireshark只能查看封包，而不能修改封包的内容，或者发送封包。Wireshark能够对大部分局域网协议进行解析，具有界面简单、操作方便、实时显示捕获数据的优点。Wireshark不是入侵侦测系统，对于网络上的异常流量行为，Wireshark不会产生警示或是任何提示。然而，仔细分析Wireshark撷取的封包能够帮助使用者对于网络行为有更清楚的了解。Wireshark的用途很广，网络管理员可以使用Wireshark来检测网络问题，网络安全工程师可以使用Wireshark来检查资讯安全相关问题，开发者可以使用Wireshark来为新的通讯协议除错，普通使用者可以使用Wireshark来学习网络协议的相关知识。<br>在使用Wireshark工具时，可以按如下流程进行：</p><ol><li>确定Wireshark的位置。即在哪执行wireshark命令，如果没有一个正确的位置，启动Wireshark后会花费很长的时间捕获一些与自己无关的数据。</li><li>选择捕获接口。一般都是选择连接到Internet网络的接口，这样才可以捕获到与网络相关的数据。否则，捕获到的其它数据对自己也没有任何帮助。</li><li>使用捕获过滤器。通过设置捕获过滤器，可以避免产生过大的捕获文件。这样用户在分析数据时，也不会受其它数据干扰。而且，还可以为用户节约大量的时间。</li><li>使用显示过滤器。通常使用捕获过滤器过滤后的数据，往往还是很复杂。为了使过滤的数据包再更细致，此时使用显示过滤器进行过滤。</li><li>使用着色规则。通常使用显示过滤器过滤后的数据，都是有用的数据包。如果想更加突出的显示某个会话，可以使用着色规则高亮显示。</li><li>构建图表。如果用户想要更明显的看出一个网络中数据的变化情况，使用图表的形式可以很方便的展现数据分布情况。</li><li>重组数据。Wireshark的重组功能，可以重组一个会话中不同数据包的信息，或者是一个重组一个完整的图片或文件。由于传输的文件往往较大，所以信息分布在多个数据包中。为了能够查看到整个图片或文件，这时候就需要使用重组数据的方法来实现。<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3></li></ol><p>控制器：Ubuntu14.03桌面版,Floodlight1.0;CPU:1,内存:2GB,磁盘:20GB</p><p>交换机：Ubuntu14.03桌面版,OVS2.3.1;CPU:1,内存:2GB,磁盘:20GB</p><h3 id="基本使用步骤"><a href="#基本使用步骤" class="headerlink" title="基本使用步骤"></a>基本使用步骤</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> apt-get install wireshark <span class="comment"># root用户下安装</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo wireshark <span class="comment"># 普通用户下打开wireshark主界面，这里权限的问题，root打不开，普通用户无法获得网卡</span></span></span><br></pre></td></tr></table></figure><h4 id="步骤-1-选择需要抓包的网卡"><a href="#步骤-1-选择需要抓包的网卡" class="headerlink" title="步骤 1 选择需要抓包的网卡"></a>步骤 1 选择需要抓包的网卡</h4><p>Wireshark是捕获机器上的某一块网卡的网络包，当你的机器上有多块网卡的时候，你需要选择一个网卡，请按下面的方式选择网卡：</p><ul><li>方式一：选择网卡“eth0”，单击开始按钮</li><li>方式二：1)在菜单栏选择”Capture -&gt; Interfaces”，进入选择网卡的页面;2)选择网卡“eth0”，单击“Start”，进入抓包页面</li></ul><p><img src="https://ganshizhong.gitee.io/blogimages/SDN/Wireshark/wiresharkui.png"></p><h4 id="步骤-2-单击浏览器图标，打开浏览器，在浏览器上访问www-sina-com-cn，进行抓包"><a href="#步骤-2-单击浏览器图标，打开浏览器，在浏览器上访问www-sina-com-cn，进行抓包" class="headerlink" title="步骤 2 单击浏览器图标，打开浏览器，在浏览器上访问www.sina.com.cn，进行抓包"></a>步骤 2 单击浏览器图标，打开浏览器，在浏览器上访问<a href="http://www.sina.com.cn,进行抓包/">www.sina.com.cn，进行抓包</a></h4><h4 id="步骤-3-单击红色停止按钮停止抓包，抓包结果如下图所示"><a href="#步骤-3-单击红色停止按钮停止抓包，抓包结果如下图所示" class="headerlink" title="步骤 3 单击红色停止按钮停止抓包，抓包结果如下图所示"></a>步骤 3 单击红色停止按钮停止抓包，抓包结果如下图所示</h4><p><img src="https://ganshizhong.gitee.io/blogimages/SDN/Wireshark/wiresharkcapturing.png"></p><p>图中四个区域分别为：</p><ol><li>为DISPLAY FILTER（显示过滤器），显示过滤器用于查找捕捉记录中的内容。</li><li>为PACKET LIST PANE（封包列表），封包列表中显示所有已经捕获的封包。可以看到发送或接收方的MAC/IP地址、TCP/UDP端口号、协议或封包的内容。</li><li>为PACKET DETAILS PANE（封包详细信息）：这里显示的是在封包列表中被选中项目的详细信息。</li><li>为DISSECTOR PANE（16进制数据）：“解析器”在Wireshark中也被叫做“16进制数据查看面板”。这里显示的内容与“封包详细信息”中相同，只是改为以16进制的格式表述。</li></ol><h4 id="步骤-4-根据抓包结果，分析抓包数据"><a href="#步骤-4-根据抓包结果，分析抓包数据" class="headerlink" title="步骤 4 根据抓包结果，分析抓包数据"></a>步骤 4 根据抓包结果，分析抓包数据</h4><ul><li>在封包列表部分选择一条TCP协议数据，如下图所示。</li><li>在封包列表部分选择一条TCP协议数据，如下图所示。</li></ul><p><img src="https://ganshizhong.gitee.io/blogimages/SDN/Wireshark/captureanalysis.png"></p><p>图中：</p><ul><li>Frame：表示物理层数据帧概况。</li><li>Ethernet II：表示数据链路层以太网帧头部信息。</li><li>Internet Protocol Version 4：表示互联网IP包头信息。</li><li>Transmission Control Protocol：表示传输层数据段头部信息，此处为TCP。</li></ul><p><img src="https://ganshizhong.gitee.io/blogimages/SDN/Wireshark/capturemessage.png"></p><p>图中：</p><ul><li>数据链路层显示有源MAC地址，目的MAC地址。</li><li>网络层IP的版本信息显示为IPv4。协议为TCP。源IP地址30.0.0.93即本机IP地址，目的IP地址10.168.16.15即远端服务器地址。</li><li>源端口为5901，目的端口为52356。</li></ul><h4 id="步骤-5-过滤报文信息"><a href="#步骤-5-过滤报文信息" class="headerlink" title="步骤 5 过滤报文信息"></a>步骤 5 过滤报文信息</h4><ul><li>过滤源IP地址<ul><li>如查找源地址为30.0.0.93的报文，则在过滤框中输入ip.src==30.0.0.93进行过滤</li></ul></li><li>过滤目的IP地址<ul><li>如查找目的地址为10.168.16.15的报文，则在过滤框中输入ip.dst==10.168.16.15进行过滤</li></ul></li><li>过滤端口<ul><li>如过滤52356端口，则在过滤框中输入tcp.port==52356||udp.port==52356</li></ul></li><li>过滤协议<ul><li>如过滤TCP的协议，则在过滤框中输入协议名tcp进行过滤</li></ul></li><li>使用连接符and过滤。<ul><li>过滤两种条件时，使用and连接，如过滤ip为30.0.0.93并且为TCP协议的报文，则在过滤框中输入ip.src==30.0.0.93 and tcp进行过滤，如下图所示。步骤 6 保存Wireshark抓包数据。</li></ul></li></ul><p>捕获的数据信息可以保存在文件中，这样就可以随时在Wireshark中打开此文件进行分析，而无需再次捕获同样的数据。关闭数据捕获屏幕或退出Wireshark时，系统会提示你保存信息</p><h3 id="练习题-1"><a href="#练习题-1" class="headerlink" title="练习题"></a>练习题</h3><p>下面关于Wireshark说法错误的是（D）</p><ul><li>A. 捕获过滤器用来过滤捕获的封包，以免捕获太多的记录。</li><li>B. 封包列表中显示所有已经捕获的封包。可以看到发送或接收方的MAC/IP地址、TCP/UDP端口号、协议或封包的内容。</li><li>C. 显示过滤器用来告诉Wireshark只显示那些符合过滤条件的数据包。</li><li>D. Wireshark能够对大部分局域网协议进行解析，能够查看、修改封包的内容，具有界面简单、操作方便、实时显示捕获数据的优点。</li></ul><p>下面关于Wireshark的过滤表达式描述错误的是（B）</p><ul><li>A. 过滤ip为10.0.1.1并且为http协议的报文，表达式为：ip.src==10.0.1.1 and http。</li><li>B. 如果没有特别指明来源或目的地，则默认使用源地址进行过滤。</li><li>C. 否(“not”)具有最高的优先级，或(“or”)和与(“and”)具有相同的优先级，运算时从左至右进行。</li><li>D. 对目的地址为192.168.0.1的包的过滤，表达式为：ip.dst eq 192.168.0.1。</li></ul><p>判断：封包列表的面板中显示：编号、时间戳、源地址、目标地址、协议、长度以及封包信息，不同的协议用了不同的颜色显示，也可以自己修改这些显示的颜色规则。 √</p><p>判断：Wireshark的捕捉过滤器支持协议过滤和内容过滤。×</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;SDN学习目录&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;/2021/04/09/SDN/SDN00_wireshark/&quot;&gt;SDN学习笔记(0)–wireshark抓包分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/2021/04</summary>
      
    
    
    
    <category term="SDN" scheme="http://shizhonggan.github.io/categories/SDN/"/>
    
    
    <category term="性能测试" scheme="http://shizhonggan.github.io/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
    <category term="网络" scheme="http://shizhonggan.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo markdown 插入图片解决方法</title>
    <link href="http://shizhonggan.github.io/2021/04/07/HexoStudy/HexoImageFile/"/>
    <id>http://shizhonggan.github.io/2021/04/07/HexoStudy/HexoImageFile/</id>
    <published>2021-04-07T12:41:21.000Z</published>
    <updated>2021-04-09T00:58:36.080Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>官方解决办法： <a href="https://hexo.io/zh-cn/docs/asset-folders.html">https://hexo.io/zh-cn/docs/asset-folders.html</a></p><p>我尝试了一下这个官方办法，并未成功。于是，不得不尝试大家推荐的“图床”办法。</p><p>“图床”即第三方存储图片的地方，并能支持http/https协议以提供图片访问链接。减轻本地服务器空间，加快图片打开速度。</p><p>提供图床的第三方网站众多。出于对安全、网站服务能力的考量，建议采用gitee 作为图片托管仓库。</p><h2 id="具体方法"><a class="markdownIt-Anchor" href="#具体方法"></a> 具体方法</h2><ol><li>新建仓库</li><li>仓库下新建index.html，此时service 里便出现gitee pages功能</li><li>点击gitee pages进入设置，直接默认确定即可，然后出现该网页链接地址 url</li><li>克隆到本地,然后将你需要的图片放到该目录下</li><li>push到仓库</li><li>于是，可以通过url+path的方式访问图片</li><li>markdown可以直接使用</li></ol><blockquote><p>温馨提示1：图要加水印</p><p>温馨提示2：gitee每次更新都要进入service-&gt;gitee page-&gt;update</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;官方解决办法： &lt;a href=&quot;https://hexo.io/zh-cn/docs/asset-folders.html&quot;&gt;https://</summary>
      
    
    
    
    <category term="Hexo" scheme="http://shizhonggan.github.io/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="http://shizhonggan.github.io/tags/Hexo/"/>
    
    <category term="前端" scheme="http://shizhonggan.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Gitalk 评论登录出现403 解决方法</title>
    <link href="http://shizhonggan.github.io/2021/04/07/HexoStudy/Gitalk403Solution/"/>
    <id>http://shizhonggan.github.io/2021/04/07/HexoStudy/Gitalk403Solution/</id>
    <published>2021-04-07T11:22:12.000Z</published>
    <updated>2021-04-09T01:07:43.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a class="markdownIt-Anchor" href="#起因"></a> 起因</h2><p><strong>网络受限</strong></p><p>本篇文章参考：<a href="https://cuiqingcai.com/30010.html">https://cuiqingcai.com/30010.html</a></p><h4 id="问题二"><a class="markdownIt-Anchor" href="#问题二"></a> 问题二</h4><p>Related <a href="https://github.com/ShizhongGan/gitalkcomments/issues">Issues</a> not found</p><p>Please contact @ShizhongGan to initialize the comment</p><h2 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h2><ol><li>用代理啊</li><li>换其他的</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#起因&quot;&gt;&lt;/a&gt; 起因&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;网络受限&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本篇文章参考：&lt;a href=&quot;https://cuiqingcai.com/3001</summary>
      
    
    
    
    <category term="Hexo" scheme="http://shizhonggan.github.io/categories/Hexo/"/>
    
    
    <category term="hexo" scheme="http://shizhonggan.github.io/tags/hexo/"/>
    
    <category term="gitalk" scheme="http://shizhonggan.github.io/tags/gitalk/"/>
    
  </entry>
  
  <entry>
    <title>vs code 实用扩展插件</title>
    <link href="http://shizhonggan.github.io/2021/04/07/Tips/vscode_tips/"/>
    <id>http://shizhonggan.github.io/2021/04/07/Tips/vscode_tips/</id>
    <published>2021-04-07T06:32:06.000Z</published>
    <updated>2021-04-09T01:06:41.360Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Angular 8 and TypeScript/HTML VS Code Snippets</li><li>Awesome Flutter Snippets</li><li>Chinese (Simplified) Language Pack for Visual Studio Code</li><li>Code Runner</li><li>Code Spell Checker</li><li>Dart</li><li>Docker</li><li><a href="http://Draw.io">Draw.io</a> Integration</li><li>Flutter</li><li>Graphviz Interactive Preview</li><li>HTML Boilerplate</li><li>Jupyter</li><li>LaTeX Workshop</li><li>Live Server</li><li>Markdown All in One</li><li>Markdown Mind Map Preview</li><li>Markdown PDF</li><li>Markdown+Math</li><li>Office Viewer</li><li>open in browser</li><li>PlantUML</li><li>python</li><li>reStructuredText</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;Angular 8 and TypeScript/HTML VS Code Snippets&lt;/li&gt;
&lt;li&gt;Awesome Flutter Snippets&lt;/li&gt;
&lt;li&gt;Chinese (Simplified) Language Pack for Vi</summary>
      
    
    
    
    <category term="Tips" scheme="http://shizhonggan.github.io/categories/Tips/"/>
    
    
    <category term="vs code插件" scheme="http://shizhonggan.github.io/tags/vs-code%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Gitee部署Hexo 博客</title>
    <link href="http://shizhonggan.github.io/2021/04/07/HexoStudy/HexoGiteeDeploy/"/>
    <id>http://shizhonggan.github.io/2021/04/07/HexoStudy/HexoGiteeDeploy/</id>
    <published>2021-04-07T01:21:46.000Z</published>
    <updated>2021-04-09T00:58:39.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>由于网络限制，Github部署Hexo博客加载速度慢，因此建议采用gitee进行部署。</p><h2 id="部署方法"><a class="markdownIt-Anchor" href="#部署方法"></a> 部署方法</h2><ol><li>注册gitee账号</li><li>新建公开仓库<ul><li>访问地址不带二级目录设置：如果你想你的 pages 首页访问地址不带二级目录，<a href="https://link.juejin.im/?target=http%3A%2F%2Fxn--ipvb-f96g.gitee.io">如ipvb.gitee.io</a>，你需要建立一个与自己个性地址同名的项目，如 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgitee.com%2Fipvb">gitee.com/ipvb</a> 这个用户，想要创建一个自己的站点，但不想以子目录的方式访问，想以ipvb.oschina.io直接访问，那么他就可以创建一个名字为ipvb的项目 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgitee.com%2Fipvb%2Fipvb">gitee.com/ipvb/ipvb</a> 部署完成后，就可以以 <a href="https://link.juejin.im/?target=https%3A%2F%2Fipvb.gitee.io">ipvb.gitee.io</a> 进行访问了。</li></ul></li><li>设置hexo _config.yml文件，绑定该新建的仓库</li><li>hexo d部署</li><li>该仓库的service出现gitee page功能，点击进去默认确定即可</li><li>然后通过ipvb.gitee.io即可访问</li></ol><blockquote><p>温馨提示：每次hexo d部署完，都要进入gitee page功能中update，否则无法看到网页变化。github不需要。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#前言&quot;&gt;&lt;/a&gt; 前言&lt;/h2&gt;
&lt;p&gt;由于网络限制，Github部署Hexo博客加载速度慢，因此建议采用gitee进行部署。&lt;/p&gt;
&lt;h2 id=&quot;部署方法&quot;&gt;&lt;a class=&quot;</summary>
      
    
    
    
    <category term="Hexo" scheme="http://shizhonggan.github.io/categories/Hexo/"/>
    
    
    <category term="Gitee" scheme="http://shizhonggan.github.io/tags/Gitee/"/>
    
    <category term="Hexo" scheme="http://shizhonggan.github.io/tags/Hexo/"/>
    
  </entry>
  
</feed>
